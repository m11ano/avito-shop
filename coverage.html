
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/m11ano/avito-shop/cmd/app/main.go (0.0%)</option>
				
				<option value="file1">github.com/m11ano/avito-shop/internal/bootstrap/app.go (56.7%)</option>
				
				<option value="file2">github.com/m11ano/avito-shop/internal/bootstrap/inf_http_fiber.go (90.0%)</option>
				
				<option value="file3">github.com/m11ano/avito-shop/internal/bootstrap/inf_logger.go (71.4%)</option>
				
				<option value="file4">github.com/m11ano/avito-shop/internal/bootstrap/inf_pgxv5.go (57.7%)</option>
				
				<option value="file5">github.com/m11ano/avito-shop/internal/delivery/http/controller/auth.go (93.8%)</option>
				
				<option value="file6">github.com/m11ano/avito-shop/internal/delivery/http/controller/buy.go (77.8%)</option>
				
				<option value="file7">github.com/m11ano/avito-shop/internal/delivery/http/controller/controller.go (100.0%)</option>
				
				<option value="file8">github.com/m11ano/avito-shop/internal/delivery/http/controller/info.go (82.4%)</option>
				
				<option value="file9">github.com/m11ano/avito-shop/internal/delivery/http/controller/send_coin.go (80.8%)</option>
				
				<option value="file10">github.com/m11ano/avito-shop/internal/delivery/http/middleware/auth.go (91.7%)</option>
				
				<option value="file11">github.com/m11ano/avito-shop/internal/delivery/http/middleware/error_handler.go (90.0%)</option>
				
				<option value="file12">github.com/m11ano/avito-shop/internal/delivery/http/middleware/logger.go (93.8%)</option>
				
				<option value="file13">github.com/m11ano/avito-shop/internal/delivery/http/middleware/recovery.go (30.8%)</option>
				
				<option value="file14">github.com/m11ano/avito-shop/internal/delivery/http/middleware/trace_id.go (100.0%)</option>
				
				<option value="file15">github.com/m11ano/avito-shop/internal/delivery/http/register_routes.go (100.0%)</option>
				
				<option value="file16">github.com/m11ano/avito-shop/internal/delivery/http/validation/format_errors.go (85.7%)</option>
				
				<option value="file17">github.com/m11ano/avito-shop/internal/delivery/http/validation/validator.go (100.0%)</option>
				
				<option value="file18">github.com/m11ano/avito-shop/internal/domain/account.go (83.3%)</option>
				
				<option value="file19">github.com/m11ano/avito-shop/internal/domain/coin_transfer.go (0.0%)</option>
				
				<option value="file20">github.com/m11ano/avito-shop/internal/domain/operation.go (0.0%)</option>
				
				<option value="file21">github.com/m11ano/avito-shop/internal/domain/shop_item.go (0.0%)</option>
				
				<option value="file22">github.com/m11ano/avito-shop/internal/domain/shop_purchase.go (0.0%)</option>
				
				<option value="file23">github.com/m11ano/avito-shop/internal/infra/config/config.go (80.0%)</option>
				
				<option value="file24">github.com/m11ano/avito-shop/internal/infra/db/migrations/goose_logger.go (66.7%)</option>
				
				<option value="file25">github.com/m11ano/avito-shop/internal/infra/db/migrations/migrate.go (55.6%)</option>
				
				<option value="file26">github.com/m11ano/avito-shop/internal/infra/db/txmngr/provider.go (100.0%)</option>
				
				<option value="file27">github.com/m11ano/avito-shop/internal/infra/db/txmngr/tx_manager.go (100.0%)</option>
				
				<option value="file28">github.com/m11ano/avito-shop/internal/repository/account.go (55.4%)</option>
				
				<option value="file29">github.com/m11ano/avito-shop/internal/repository/coin_transfer.go (46.8%)</option>
				
				<option value="file30">github.com/m11ano/avito-shop/internal/repository/operation.go (51.4%)</option>
				
				<option value="file31">github.com/m11ano/avito-shop/internal/repository/shop_item.go (41.2%)</option>
				
				<option value="file32">github.com/m11ano/avito-shop/internal/repository/shop_purchase.go (46.8%)</option>
				
				<option value="file33">github.com/m11ano/avito-shop/internal/usecase/account.go (100.0%)</option>
				
				<option value="file34">github.com/m11ano/avito-shop/internal/usecase/auth.go (93.3%)</option>
				
				<option value="file35">github.com/m11ano/avito-shop/internal/usecase/coin_transfer.go (100.0%)</option>
				
				<option value="file36">github.com/m11ano/avito-shop/internal/usecase/operation.go (100.0%)</option>
				
				<option value="file37">github.com/m11ano/avito-shop/internal/usecase/shop_item.go (100.0%)</option>
				
				<option value="file38">github.com/m11ano/avito-shop/internal/usecase/shop_purchase.go (100.0%)</option>
				
				<option value="file39">github.com/m11ano/avito-shop/pkg/dbhelper/helpers.go (83.8%)</option>
				
				<option value="file40">github.com/m11ano/avito-shop/pkg/e/error.go (95.1%)</option>
				
				<option value="file41">github.com/m11ano/avito-shop/pkg/e/error_helpers.go (100.0%)</option>
				
				<option value="file42">github.com/m11ano/avito-shop/tests/mocks/account.go (65.1%)</option>
				
				<option value="file43">github.com/m11ano/avito-shop/tests/mocks/account_repository.go (65.1%)</option>
				
				<option value="file44">github.com/m11ano/avito-shop/tests/mocks/auth.go (0.0%)</option>
				
				<option value="file45">github.com/m11ano/avito-shop/tests/mocks/coin_transfer.go (0.0%)</option>
				
				<option value="file46">github.com/m11ano/avito-shop/tests/mocks/coin_transfer_repository.go (64.3%)</option>
				
				<option value="file47">github.com/m11ano/avito-shop/tests/mocks/operation.go (27.0%)</option>
				
				<option value="file48">github.com/m11ano/avito-shop/tests/mocks/operation_repository.go (62.2%)</option>
				
				<option value="file49">github.com/m11ano/avito-shop/tests/mocks/pgx_pool.go (6.7%)</option>
				
				<option value="file50">github.com/m11ano/avito-shop/tests/mocks/pgx_pool_for_tx_manager.go (100.0%)</option>
				
				<option value="file51">github.com/m11ano/avito-shop/tests/mocks/pgx_pool_tx.go (8.7%)</option>
				
				<option value="file52">github.com/m11ano/avito-shop/tests/mocks/shop_item.go (44.0%)</option>
				
				<option value="file53">github.com/m11ano/avito-shop/tests/mocks/shop_item_repository.go (66.0%)</option>
				
				<option value="file54">github.com/m11ano/avito-shop/tests/mocks/shop_purchase.go (0.0%)</option>
				
				<option value="file55">github.com/m11ano/avito-shop/tests/mocks/shop_purchase_repository.go (64.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "time"

        "github.com/m11ano/avito-shop/internal/bootstrap"
        "github.com/m11ano/avito-shop/internal/infra/config"
        "go.uber.org/fx"
)

func main() <span class="cov0" title="0">{
        cfg := config.LoadConfig("config.yml")

        app := fx.New(
                fx.Options(
                        fx.StartTimeout(time.Second*time.Duration(cfg.App.StartTimeout)),
                        fx.StopTimeout(time.Second*time.Duration(cfg.App.StopTimeout)),
                ),
                fx.Provide(func() config.Config </span><span class="cov0" title="0">{
                        return cfg
                }</span>),
                bootstrap.App,
        )

        <span class="cov0" title="0">app.Run()</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package bootstrap

import (
        "context"
        "fmt"
        "log/slog"
        "os"
        "runtime/debug"
        "time"

        trmpgx "github.com/avito-tech/go-transaction-manager/drivers/pgxv5/v2"
        "github.com/avito-tech/go-transaction-manager/trm/v2/manager"
        "github.com/gofiber/fiber/v2"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/m11ano/avito-shop/internal/infra/config"
        "github.com/m11ano/avito-shop/internal/infra/db/migrations"
        "github.com/m11ano/avito-shop/internal/infra/db/txmngr"
        "go.uber.org/fx"
        "go.uber.org/fx/fxevent"
)

var App = fx.Options(
        // Инфраструктура
        fx.Provide(NewLogger),
        fx.WithLogger(func(config config.Config) fxevent.Logger <span class="cov8" title="1">{
                if !config.App.UseFxLogger </span><span class="cov8" title="1">{
                        return fxevent.NopLogger
                }</span>
                <span class="cov0" title="0">return &amp;fxevent.ConsoleLogger{
                        W: os.Stdout,
                }</span>
        }),
        fx.Provide(NewPgxv5),
        fx.Provide(func(config config.Config, logger *slog.Logger) *fiber.App <span class="cov8" title="1">{
                fiberApp := NewHTTPFiber(HTTPConfig{
                        UnderProxy: config.HTTP.UnderProxy,
                        UseTraceID: true,
                        UseLogger:  true,
                }, logger)
                return fiberApp
        }</span>),
        fx.Provide(func(pgxpool *pgxpool.Pool) (*manager.Manager, *trmpgx.CtxGetter) <span class="cov8" title="1">{
                return txmngr.New(pgxpool)
        }</span>),
        // Бизнес логика
        AccountModule,
        OperationModule,
        AuthModule,
        ShopItemModule,
        ShopPurchaseModule,
        CoinTransferModule,
        // Delivery
        DeliveryHTTP,
        // Start &amp;&amp; Stop invoke
        fx.Invoke(func(lc fx.Lifecycle, shutdowner fx.Shutdowner, logger *slog.Logger, config config.Config, dbpool *pgxpool.Pool, fiberApp *fiber.App) <span class="cov8" title="1">{
                lc.Append(fx.Hook{
                        OnStart: func(ctx context.Context) error </span><span class="cov8" title="1">{
                                err := Pgxv5TestConnection(ctx, dbpool, logger, config.DB.MaxAttempt, config.DB.AttemptSleepSeconds)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">logger.Info("Postgress connected")

                                err = migrations.RunMigrations(ctx, dbpool, config, logger)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov8" title="1">if config.HTTP.Port &gt; 0 </span><span class="cov0" title="0">{
                                        go func() </span><span class="cov0" title="0">{
                                                if err := fiberApp.Listen(fmt.Sprintf(":%d", config.HTTP.Port)); err != nil </span><span class="cov0" title="0">{
                                                        logger.Error("failed to start fiber", slog.Any("error", err), slog.Any("trackeback", string(debug.Stack())))
                                                        err := shutdowner.Shutdown()
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                logger.Error("failed to shutdown", slog.Any("error", err), slog.Any("trackeback", string(debug.Stack())))
                                                        }</span>
                                                }
                                        }()
                                }

                                <span class="cov8" title="1">return nil</span>
                        },
                        OnStop: func(_ context.Context) error <span class="cov8" title="1">{
                                if config.HTTP.Port &gt; 0 </span><span class="cov0" title="0">{
                                        logger.Info("stopping HTTP Fiber")
                                        err := fiberApp.ShutdownWithTimeout(time.Duration(config.HTTP.StopTimeout) * time.Second)
                                        if err != nil </span><span class="cov0" title="0">{
                                                logger.Error("failed to stop fiber", slog.Any("error", err), slog.Any("trackeback", string(debug.Stack())))
                                        }</span>
                                }

                                <span class="cov8" title="1">logger.Info("stopping Postgress")
                                dbpool.Close()

                                return nil</span>
                        },
                })
        }),
)
</pre>
		
		<pre class="file" id="file2" style="display: none">package bootstrap

import (
        "log/slog"

        "github.com/gofiber/fiber/v2"
        "github.com/m11ano/avito-shop/internal/delivery/http/middleware"
)

type HTTPConfig struct {
        UnderProxy bool
        UseTraceID bool
        UseLogger  bool
}

func NewHTTPFiber(httpCfg HTTPConfig, logger *slog.Logger) *fiber.App <span class="cov8" title="1">{
        fiberCfg := fiber.Config{
                ErrorHandler: middleware.ErrorHandler(),
        }

        if httpCfg.UnderProxy </span><span class="cov0" title="0">{
                fiberCfg.ProxyHeader = fiber.HeaderXForwardedFor
        }</span>

        <span class="cov8" title="1">app := fiber.New(fiberCfg)

        app.Use(middleware.Recovery(logger))

        if httpCfg.UseTraceID </span><span class="cov8" title="1">{
                app.Use(middleware.TraceID())
        }</span>

        <span class="cov8" title="1">if httpCfg.UseLogger </span><span class="cov8" title="1">{
                app.Use(middleware.Logger(logger))
        }</span>

        <span class="cov8" title="1">return app</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package bootstrap

import (
        "io"
        "log/slog"
        "os"

        "github.com/m11ano/avito-shop/internal/infra/config"
)

func NewLogger(config config.Config) *slog.Logger <span class="cov8" title="1">{
        var handler slog.Handler
        switch </span>{
        case !config.App.UseLogger:<span class="cov8" title="1">
                handler = slog.NewTextHandler(io.Discard, nil)</span>
        case config.App.IsProd:<span class="cov0" title="0">
                handler = slog.NewJSONHandler(os.Stdout, nil)</span>
        default:<span class="cov0" title="0">
                handler = slog.NewTextHandler(os.Stdout, nil)</span>
        }

        <span class="cov8" title="1">logger := slog.New(handler)
        return logger</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package bootstrap

import (
        "context"
        "fmt"
        "log/slog"
        "time"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/m11ano/avito-shop/internal/infra/config"
)

type pgxv5Tracer struct {
        logger *slog.Logger
}

func (t *pgxv5Tracer) TraceQueryStart(ctx context.Context, _ *pgx.Conn, data pgx.TraceQueryStartData) context.Context <span class="cov0" title="0">{
        t.logger.Info(fmt.Sprintf("Начало запроса: %s, args: %v", data.SQL, data.Args))
        return ctx
}</span>

func (t *pgxv5Tracer) TraceQueryEnd(_ context.Context, _ *pgx.Conn, data pgx.TraceQueryEndData) <span class="cov0" title="0">{
        t.logger.Info(fmt.Sprintf("Завершение запроса: %s, ошибка: %v", data.CommandTag, data.Err))
}</span>

func NewPgxv5(config config.Config, logger *slog.Logger) *pgxpool.Pool <span class="cov8" title="1">{
        ctx := context.Background()
        pgxCfg, err := pgxpool.ParseConfig(config.DB.URI)
        if err != nil </span><span class="cov0" title="0">{
                panic("unable to parse db uri string")</span>
        }

        <span class="cov8" title="1">if !config.App.IsProd </span><span class="cov0" title="0">{
                pgxCfg.ConnConfig.Tracer = &amp;pgxv5Tracer{logger: logger}
        }</span>

        <span class="cov8" title="1">dbpool, err := pgxpool.NewWithConfig(ctx, pgxCfg)
        if err != nil </span><span class="cov0" title="0">{
                panic("unable to create pgxv5 connection pool")</span>
        }

        <span class="cov8" title="1">return dbpool</span>
}

func Pgxv5TestConnection(ctx context.Context, dbpool *pgxpool.Pool, logger *slog.Logger, maxAttempt int, attemptSleepSeconds int) error <span class="cov8" title="1">{
        attemp := 1
        var err error
        for attemp &lt;= maxAttempt </span><span class="cov8" title="1">{
                err = dbpool.Ping(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Info("failed to connect to Postgress", slog.Int("attemp", attemp))
                        time.Sleep(time.Duration(attemptSleepSeconds) * time.Second)
                        attemp++
                        continue</span>
                }
                <span class="cov8" title="1">break</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package controller

import (
        "errors"

        "github.com/gofiber/fiber/v2"
        "github.com/m11ano/avito-shop/internal/delivery/http/validation"
        "github.com/m11ano/avito-shop/pkg/e"
)

type AuthHandlerOut struct {
        Token string `json:"token"`
}

type AuthHandlerIn struct {
        Username string `json:"username" validate:"required,max=255"`
        Password string `json:"password" validate:"required,max=255"`
}

func (ctrl *Controller) AuthHandlerValidate(in *AuthHandlerIn) (isOk bool, errMsg string) <span class="cov8" title="1">{
        if err := ctrl.vldtr.Struct(in); err != nil </span><span class="cov8" title="1">{
                return validation.FormatErrors(err)
        }</span>
        <span class="cov8" title="1">return true, ""</span>
}

func (ctrl *Controller) AuthHandler(c *fiber.Ctx) error <span class="cov8" title="1">{
        in := &amp;AuthHandlerIn{}

        if err := c.BodyParser(in); err != nil </span><span class="cov8" title="1">{
                return &amp;fiber.Error{Code: fiber.ErrBadRequest.Code, Message: err.Error()}
        }</span>

        <span class="cov8" title="1">ok, errMsg := ctrl.AuthHandlerValidate(in)
        if !ok </span><span class="cov8" title="1">{
                return &amp;fiber.Error{Code: fiber.ErrBadRequest.Code, Message: errMsg}
        }</span>

        <span class="cov8" title="1">jwtToken, err := ctrl.usecaseAuth.SignInOrSignUp(c.Context(), in.Username, in.Password)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, e.ErrInternal) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return e.ErrUnauthorized</span>
        }

        <span class="cov8" title="1">out := AuthHandlerOut{Token: jwtToken}

        return c.JSON(out)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package controller

import (
        "errors"

        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "github.com/m11ano/avito-shop/internal/usecase"
        "github.com/m11ano/avito-shop/pkg/e"
)

func (ctrl *Controller) BuyHandler(c *fiber.Ctx) error <span class="cov8" title="1">{
        if isAuth, ok := c.Locals("isAuth").(bool); !ok || !isAuth </span><span class="cov8" title="1">{
                return e.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">var accountID *uuid.UUID
        var ok bool
        if accountID, ok = c.Locals("authAccountID").(*uuid.UUID); !ok </span><span class="cov0" title="0">{
                return e.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">var requestID *uuid.UUID
        if requestID, ok = c.Locals("requestID").(*uuid.UUID); !ok </span><span class="cov0" title="0">{
                return e.ErrInternal
        }</span>

        <span class="cov8" title="1">shopItemName := c.Params("name")

        _, err := ctrl.usecaseShopPurchase.MakePurchase(c.Context(), shopItemName, *accountID, 1, requestID)
        if err != nil </span><span class="cov8" title="1">{
                // Маппинг ошибок под требования контракта
                switch </span>{
                case errors.Is(err, usecase.ErrOperationNotEnoughFunds):<span class="cov8" title="1">
                        return e.NewErrorFrom(e.ErrBadRequest).SetMessage(err.Error())</span>
                case errors.Is(err, e.ErrConflict):<span class="cov0" title="0">
                        return e.NewErrorFrom(e.ErrBadRequest).SetMessage(err.Error())</span>
                case errors.Is(err, e.ErrNotFound):<span class="cov8" title="1">
                        return e.NewErrorFrom(e.ErrBadRequest).SetMessage(err.Error())</span>
                default:<span class="cov0" title="0">
                        return err</span>
                }
        }

        <span class="cov8" title="1">return c.SendStatus(fiber.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package controller

import (
        "log/slog"

        "github.com/go-playground/validator/v10"
        "github.com/m11ano/avito-shop/internal/usecase"
)

type Controller struct {
        logger              *slog.Logger
        vldtr               *validator.Validate
        usecaseAuth         usecase.Auth
        usecaseOperation    usecase.Operation
        usecaseShopPurchase usecase.ShopPurchase
        usecaseCoinTransfer usecase.CoinTransfer
}

func New(logger *slog.Logger, vldtr *validator.Validate, usecaseAuth usecase.Auth, usecaseOperation usecase.Operation, usecaseShopPurchase usecase.ShopPurchase, usecaseCoinTransfer usecase.CoinTransfer) *Controller <span class="cov8" title="1">{
        return &amp;Controller{
                logger:              logger,
                vldtr:               vldtr,
                usecaseAuth:         usecaseAuth,
                usecaseOperation:    usecaseOperation,
                usecaseShopPurchase: usecaseShopPurchase,
                usecaseCoinTransfer: usecaseCoinTransfer,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package controller

import (
        "fmt"

        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "github.com/m11ano/avito-shop/internal/domain"
        "github.com/m11ano/avito-shop/pkg/e"
)

type InfoHandlerOut struct {
        Coins       int64                     `json:"coins"`
        Inventory   []InfoHandlerOutInventory `json:"inventory"`
        CoinHistory InfoHandlerOutCoinHistory `json:"coinHistory"`
}

type InfoHandlerOutInventory struct {
        Type     string `json:"type"`
        Quantity int64  `json:"quantity"`
}

type InfoHandlerOutCoinHistory struct {
        Received []InfoHandlerOutCoinHistoryReceived `json:"received"`
        Sent     []InfoHandlerOutCoinHistorySent     `json:"sent"`
}

type InfoHandlerOutCoinHistorySent struct {
        ToUser string `json:"toUser"`
        Amount int64  `json:"amount"`
}

type InfoHandlerOutCoinHistoryReceived struct {
        FromUser string `json:"fromUser"`
        Amount   int64  `json:"amount"`
}

func (ctrl *Controller) InfoHandler(c *fiber.Ctx) error <span class="cov8" title="1">{
        if isAuth, ok := c.Locals("isAuth").(bool); !ok || !isAuth </span><span class="cov8" title="1">{
                return e.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">var accountID *uuid.UUID
        var ok bool
        if accountID, ok = c.Locals("authAccountID").(*uuid.UUID); !ok </span><span class="cov0" title="0">{
                return e.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">var err error
        out := InfoHandlerOut{}

        // Получаем баланс пользователя
        out.Coins, _, err = ctrl.usecaseOperation.GetBalanceByAccountID(c.Context(), *accountID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("!!!", err)
                return err
        }</span>

        // Получаем инвентарь и перекладываем в дто ответа
        <span class="cov8" title="1">inventory, err := ctrl.usecaseShopPurchase.GetInventory(c.Context(), *accountID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">out.Inventory = make([]InfoHandlerOutInventory, 0, len(inventory))
        for _, item := range inventory </span><span class="cov8" title="1">{
                invItem := InfoHandlerOutInventory{
                        Quantity: item.Quantity,
                }
                if item.ShopItem != nil </span><span class="cov8" title="1">{
                        invItem.Type = item.ShopItem.Name
                }</span>
                <span class="cov8" title="1">out.Inventory = append(out.Inventory, invItem)</span>
        }

        // Получаем агрегированную историю полученных монет и перекладываем в дто ответа
        <span class="cov8" title="1">receivedCoinHistory, err := ctrl.usecaseCoinTransfer.GetAggrCoinHistory(c.Context(), *accountID, domain.CoinTransferTypeReciving)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">out.CoinHistory.Received = make([]InfoHandlerOutCoinHistoryReceived, 0, len(receivedCoinHistory))
        for _, item := range receivedCoinHistory </span><span class="cov8" title="1">{
                out.CoinHistory.Received = append(out.CoinHistory.Received, InfoHandlerOutCoinHistoryReceived{
                        FromUser: item.Account.Username,
                        Amount:   item.Amount,
                })
        }</span>

        // Получаем агрегированную историю отправленных монет и перекладываем в дто ответа
        <span class="cov8" title="1">sentCoinHistory, err := ctrl.usecaseCoinTransfer.GetAggrCoinHistory(c.Context(), *accountID, domain.CoinTransferTypeSending)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">out.CoinHistory.Sent = make([]InfoHandlerOutCoinHistorySent, 0, len(sentCoinHistory))
        for _, item := range sentCoinHistory </span><span class="cov8" title="1">{
                out.CoinHistory.Sent = append(out.CoinHistory.Sent, InfoHandlerOutCoinHistorySent{
                        ToUser: item.Account.Username,
                        Amount: item.Amount,
                })
        }</span>

        <span class="cov8" title="1">return c.JSON(out)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package controller

import (
        "errors"

        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "github.com/m11ano/avito-shop/internal/delivery/http/validation"
        "github.com/m11ano/avito-shop/internal/usecase"
        "github.com/m11ano/avito-shop/pkg/e"
)

type SendCoinIn struct {
        ToUser string `json:"toUser" validate:"required"`
        Amount int64  `json:"amount" validate:"gt=0"`
}

func (ctrl *Controller) SendCoinValidate(in *SendCoinIn) (bool, string) <span class="cov8" title="1">{
        if err := ctrl.vldtr.Struct(in); err != nil </span><span class="cov8" title="1">{
                return validation.FormatErrors(err)
        }</span>
        <span class="cov8" title="1">return true, ""</span>
}

func (ctrl *Controller) SendCoinHandler(c *fiber.Ctx) error <span class="cov8" title="1">{
        if isAuth, ok := c.Locals("isAuth").(bool); !ok || !isAuth </span><span class="cov8" title="1">{
                return e.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">in := &amp;SendCoinIn{}

        if err := c.BodyParser(in); err != nil </span><span class="cov8" title="1">{
                return &amp;fiber.Error{Code: fiber.ErrBadRequest.Code, Message: err.Error()}
        }</span>

        <span class="cov8" title="1">var ok bool

        ok, errMsg := ctrl.SendCoinValidate(in)
        if !ok </span><span class="cov8" title="1">{
                return &amp;fiber.Error{Code: fiber.ErrBadRequest.Code, Message: errMsg}
        }</span>

        <span class="cov8" title="1">var accountID *uuid.UUID
        if accountID, ok = c.Locals("authAccountID").(*uuid.UUID); !ok </span><span class="cov0" title="0">{
                return e.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">var requestID *uuid.UUID
        if requestID, ok = c.Locals("requestID").(*uuid.UUID); !ok </span><span class="cov0" title="0">{
                return e.ErrInternal
        }</span>

        <span class="cov8" title="1">_, _, err := ctrl.usecaseCoinTransfer.MakeTransferByUsername(c.Context(), in.ToUser, *accountID, in.Amount, requestID)
        if err != nil </span><span class="cov8" title="1">{
                // Маппинг ошибок под требования контракта
                switch </span>{
                case errors.Is(err, usecase.ErrOperationNotEnoughFunds):<span class="cov8" title="1">
                        return e.NewErrorFrom(e.ErrBadRequest).SetMessage(err.Error())</span>
                case errors.Is(err, e.ErrConflict):<span class="cov0" title="0">
                        return e.NewErrorFrom(e.ErrBadRequest).SetMessage(err.Error())</span>
                case errors.Is(err, e.ErrNotFound):<span class="cov0" title="0">
                        return e.NewErrorFrom(e.ErrBadRequest).SetMessage(err.Error())</span>
                default:<span class="cov0" title="0">
                        return err</span>
                }
        }

        <span class="cov8" title="1">return c.SendStatus(fiber.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import (
        "errors"
        "strings"

        "github.com/gofiber/fiber/v2"
        "github.com/m11ano/avito-shop/internal/usecase"
        "github.com/m11ano/avito-shop/pkg/e"
)

func Auth(authUsecase usecase.Auth) func(*fiber.Ctx) error <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                isAuth := false

                AuthorizationHeader := strings.TrimPrefix(c.Get("Authorization"), "Bearer ")

                if len(AuthorizationHeader) &gt; 0 </span><span class="cov8" title="1">{
                        accountID, err := authUsecase.AuthByJWTToken(c.Context(), AuthorizationHeader)
                        if err != nil &amp;&amp; !errors.Is(err, e.ErrUnauthorized) </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if accountID != nil </span><span class="cov8" title="1">{
                                isAuth = true
                                c.Locals("authAccountID", accountID)
                        }</span>
                }

                <span class="cov8" title="1">c.Locals("isAuth", isAuth)

                return c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package middleware

import (
        "github.com/gofiber/fiber/v2"
        "github.com/m11ano/avito-shop/pkg/e"
)

type errorJSON struct {
        Errors string `json:"errors"`
}

func ErrorHandler() func(*fiber.Ctx, error) error <span class="cov8" title="1">{
        return func(c *fiber.Ctx, err error) error </span><span class="cov8" title="1">{
                json := errorJSON{}
                code := 500

                switch errTyped := err.(type) </span>{
                case *e.LogicError:<span class="cov8" title="1">
                        code = errTyped.Code()
                        json.Errors = errTyped.Error()</span>
                case *fiber.Error:<span class="cov8" title="1">
                        code = errTyped.Code
                        json.Errors = err.Error()</span>
                default:<span class="cov0" title="0">
                        json.Errors = "internal error"</span>
                }

                <span class="cov8" title="1">return c.Status(code).JSON(json)</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package middleware

import (
        "context"
        "log/slog"
        "runtime/debug"

        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
)

type LogRequestData struct {
        Method    string `json:"method"`
        Path      string `json:"path"`
        IP        string `json:"ip"`
        URI       string `json:"uri"`
        RequestID string `json:"requestId,omitempty"`
}

func Logger(logger *slog.Logger) func(*fiber.Ctx) error <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                result := c.Next()

                if result != nil </span><span class="cov8" title="1">{
                        err := c.App().ErrorHandler(c, result)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.ErrorContext(c.Context(), "failed to call fiber error handler", slog.Any("error", err), slog.Any("trackeback", string(debug.Stack())))
                        }</span>
                }

                <span class="cov8" title="1">code := c.Response().StatusCode()

                logRequestData := LogRequestData{
                        Method: c.Method(),
                        Path:   c.Path(),
                        IP:     c.IP(),
                        URI:    string(c.Context().URI().QueryString()),
                }

                requestID := c.Locals("requestID")
                if requestID, ok := requestID.(*uuid.UUID); ok </span><span class="cov8" title="1">{
                        logRequestData.RequestID = requestID.String()
                }</span>

                <span class="cov8" title="1">go doLogging(c.Context(), logger, code, logRequestData)

                return nil</span>
        }
}

func doLogging(ctx context.Context, logger *slog.Logger, code int, data LogRequestData) <span class="cov8" title="1">{
        if code &gt;= 400 </span><span class="cov8" title="1">{
                logger.ErrorContext(
                        ctx,
                        "http response: error",
                        slog.Int("reponseCode", code),
                        slog.Any("request", data),
                )
        }</span> else<span class="cov8" title="1"> {
                logger.InfoContext(
                        ctx,
                        "http response: success",
                        slog.Int("reponseCode", code),
                        slog.Any("request", data),
                )
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package middleware

import (
        "errors"
        "fmt"
        "log/slog"
        "runtime/debug"

        "github.com/gofiber/fiber/v2"
)

func Recovery(logger *slog.Logger) func(*fiber.Ctx) error <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if errRec := recover(); errRec != nil </span><span class="cov0" title="0">{
                                var err error
                                switch errData := errRec.(type) </span>{
                                case error:<span class="cov0" title="0">
                                        err = errData</span>
                                case string:<span class="cov0" title="0">
                                        err = fmt.Errorf("panic: %s", errData)</span>
                                default:<span class="cov0" title="0">
                                        err = errors.New("panic: unknown error happend")</span>
                                }

                                <span class="cov0" title="0">handlerErr := c.App().ErrorHandler(c, err)
                                if handlerErr != nil </span><span class="cov0" title="0">{
                                        logger.ErrorContext(c.Context(), "failed to call fiber error handler", slog.Any("error", handlerErr), slog.Any("trackeback", string(debug.Stack())))
                                }</span>

                                <span class="cov0" title="0">logger.ErrorContext(c.Context(), "panic inside http request", slog.Any("error", err), slog.Any("trackeback", string(debug.Stack())))</span>
                        }
                }()

                <span class="cov8" title="1">return c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package middleware

import (
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
)

func TraceID() func(*fiber.Ctx) error <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                requestID, err := uuid.Parse(c.Get("X-Request-ID"))
                if err != nil </span><span class="cov8" title="1">{
                        requestID = uuid.New()
                }</span>

                <span class="cov8" title="1">c.Locals("requestID", &amp;requestID)

                return c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package http

import (
        "github.com/gofiber/fiber/v2"
        "github.com/m11ano/avito-shop/internal/delivery/http/controller"
        "github.com/m11ano/avito-shop/internal/delivery/http/middleware"
        "github.com/m11ano/avito-shop/internal/infra/config"
        "github.com/m11ano/avito-shop/internal/usecase"
)

func RegisterRoutes(app *fiber.App, config config.Config, ctrl *controller.Controller, authUsecase usecase.Auth) <span class="cov8" title="1">{
        authMiddleware := middleware.Auth(authUsecase)
        rootGroup := app.Group(config.HTTP.Prefix, authMiddleware)

        rootGroup.Post("/auth", ctrl.AuthHandler)
        rootGroup.Get("/info", ctrl.InfoHandler)
        rootGroup.Get("/buy/:name", ctrl.BuyHandler)
        rootGroup.Post("/sendCoin", ctrl.SendCoinHandler)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package validation

import (
        "strings"

        "github.com/go-playground/validator/v10"
)

func FormatErrors(err error) (bool, string) <span class="cov8" title="1">{
        errors := make([]string, 0)
        if validationErrors, ok := err.(validator.ValidationErrors); ok </span><span class="cov8" title="1">{
                for _, e := range validationErrors </span><span class="cov8" title="1">{
                        errors = append(errors, e.Error())
                }</span>
        }

        <span class="cov8" title="1">if len(errors) == 0 </span><span class="cov0" title="0">{
                return true, ""
        }</span>

        <span class="cov8" title="1">return false, strings.Join(errors, "; ")</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package validation

import (
        "github.com/go-playground/validator/v10"
)

func NewValidator() *validator.Validate <span class="cov8" title="1">{
        validate := validator.New()
        return validate
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package domain

import (
        "time"

        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"
)

type Account struct {
        ID           uuid.UUID
        Username     string
        PasswordHash string
        CreatedAt    time.Time
        UpdatedAt    time.Time
}

func (a *Account) GeneretePasswordHash(password string) error <span class="cov8" title="1">{
        hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.MinCost)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">a.PasswordHash = string(hash)

        return nil</span>
}

func (a *Account) VerifyPassword(password string) bool <span class="cov8" title="1">{
        err := bcrypt.CompareHashAndPassword([]byte(a.PasswordHash), []byte(password))
        return err == nil
}</span>

// New account with text password, hash will be generated automatically
func NewAccount(username string, password string) (*Account, error) <span class="cov8" title="1">{
        account := &amp;Account{
                ID:        uuid.New(),
                Username:  username,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }

        err := account.GeneretePasswordHash(password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return account, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package domain

import (
        "time"

        "github.com/google/uuid"
)

type CoinTransferType int8

const (
        CoinTransferTypeSending CoinTransferType = iota + 1
        CoinTransferTypeReciving
)

type CoinTransfer struct {
        ID                    uuid.UUID
        Type                  CoinTransferType
        OwnerAccountID        uuid.UUID
        CounterpartyAccountID uuid.UUID
        Amount                int64
        CreatedAt             time.Time
        IdentityKey           *uuid.UUID
}

func NewCoinTransfer(transferType CoinTransferType, counterpartyAccountID uuid.UUID, ownerAccountID uuid.UUID, amount int64, identityKey *uuid.UUID) *CoinTransfer <span class="cov0" title="0">{
        return &amp;CoinTransfer{
                ID:                    uuid.New(),
                Type:                  transferType,
                OwnerAccountID:        ownerAccountID,
                CounterpartyAccountID: counterpartyAccountID,
                Amount:                amount,
                CreatedAt:             time.Now(),
                IdentityKey:           identityKey,
        }
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package domain

import (
        "time"

        "github.com/google/uuid"
)

type OperationType int8

const (
        OperationTypeIncrease OperationType = iota + 1
        OperationTypeDecrease
)

type OperationSourceType int8

const (
        OperationSourceTypeDeposit OperationSourceType = iota + 1
        OperationSourceTypeShopPurchase
        OperationSourceTypeTransfer
)

type Operation struct {
        ID         uuid.UUID
        Type       OperationType
        AccountID  uuid.UUID
        Amount     int64
        SourceType OperationSourceType
        SourceID   *uuid.UUID
        CreatedAt  time.Time
}

func NewOperation(opertationType OperationType, accountID uuid.UUID, amount int64, sourceType OperationSourceType, sourceID *uuid.UUID) *Operation <span class="cov0" title="0">{
        return &amp;Operation{
                ID:         uuid.New(),
                Type:       opertationType,
                AccountID:  accountID,
                Amount:     amount,
                SourceType: sourceType,
                SourceID:   sourceID,
                CreatedAt:  time.Now(),
        }
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package domain

import "github.com/google/uuid"

type ShopItem struct {
        ID    uuid.UUID
        Name  string
        Price int64
}

func NewShopItem(name string, price int64) *ShopItem <span class="cov0" title="0">{
        return &amp;ShopItem{
                ID:    uuid.New(),
                Name:  name,
                Price: price,
        }
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package domain

import (
        "time"

        "github.com/google/uuid"
)

type ShopPurchase struct {
        ID          uuid.UUID
        ItemID      uuid.UUID
        AccountID   uuid.UUID
        Quantity    int64
        CreatedAt   time.Time
        IdentityKey *uuid.UUID
}

func NewShopPurchase(itemID uuid.UUID, accountID uuid.UUID, quantity int64, identityKey *uuid.UUID) *ShopPurchase <span class="cov0" title="0">{
        return &amp;ShopPurchase{
                ID:          uuid.New(),
                ItemID:      itemID,
                AccountID:   accountID,
                Quantity:    quantity,
                CreatedAt:   time.Now(),
                IdentityKey: identityKey,
        }
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package config

import (
        "log"

        "github.com/ilyakaznacheev/cleanenv"
)

type Config struct {
        App struct {
                StartTimeout int  `yaml:"start_timeout" env:"APP_START_TIMEOUT" env-default:"60"`
                StopTimeout  int  `yaml:"stop_timeout" env:"APP_STOP_TIMEOUT" env-default:"10"`
                IsProd       bool `yaml:"is_prod" env:"APP_IS_PROD" env-default:"false"`
                UseLogger    bool `yaml:"use_logger" env:"APP_USE_LOGGER" env-default:"true"`
                UseFxLogger  bool `yaml:"use_fx_logger" env:"APP_USE_FX_LOGGER" env-default:"false"`
        } `yaml:"app"`
        DB struct {
                URI                 string `yaml:"uri" env:"DB_URI"`
                MaxAttempt          int    `yaml:"max_attempts" env:"DB_MAX_ATTEMPTS" env-default:"10"`
                AttemptSleepSeconds int    `yaml:"attempt_sleep_seconds" env:"DB_ATTEMPT_SLEEP_SECONDS" env-default:"3"`
                MigrationsPath      string `yaml:"migrations_path" env:"DB_MIGRATIONS_PATH" env-default:"migrations"`
        } `yaml:"db"`
        HTTP struct {
                Prefix      string `yaml:"prefix" env:"HTTP_PREFIX" env-default:"api"`
                Port        int    `yaml:"port" env:"HTTP_PORT" env-default:"8080"`
                StopTimeout int    `yaml:"stop_timeout" env:"HTTP_STOP_TIMEOUT" env-default:"5"`
                UnderProxy  bool   `yaml:"under_proxy" env:"HTTP_UNDER_PROXY" env-default:"false"`
        }
        Auth struct {
                JWTSecretKey     string `yaml:"jwt_secret_key" env:"AUTH_JWT_SECRET_KEY" env-default:""`
                JWTTokenTTL      int64  `yaml:"jwt_token_ttl" env:"AUTH_JWT_TOKEN_TTL" env-default:"3600"`
                NewAccountAmount int64  `yaml:"new_account_amount" env:"AUTH_NEW_ACCOUNT_AMOUNT" env-default:"0"`
        }
}

func LoadConfig(file string) Config <span class="cov8" title="1">{
        //
        var Config Config

        err := cleanenv.ReadConfig(file, &amp;Config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("config error", err)
        }</span>

        <span class="cov8" title="1">return Config</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package migrations

import (
        "fmt"
        "log/slog"
)

type SlogLogger struct {
        logger *slog.Logger
}

func NewSlogLogger(logger *slog.Logger) *SlogLogger <span class="cov8" title="1">{
        return &amp;SlogLogger{
                logger: logger,
        }
}</span>

func (l *SlogLogger) Fatalf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.logger.Error(fmt.Sprintf(format, v...))
}</span>

func (l *SlogLogger) Printf(format string, v ...interface{}) <span class="cov8" title="1">{
        l.logger.Info(fmt.Sprintf(format, v...))
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package migrations

import (
        "context"
        "log/slog"

        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/jackc/pgx/v5/stdlib"
        "github.com/m11ano/avito-shop/internal/infra/config"
        "github.com/pressly/goose/v3"
)

func RunMigrations(_ context.Context, pool *pgxpool.Pool, config config.Config, logger *slog.Logger) error <span class="cov8" title="1">{
        if err := goose.SetDialect("postgres"); err != nil </span><span class="cov0" title="0">{
                logger.Error("goose: unable to set dialect", slog.Any("error", err))
                return err
        }</span>
        <span class="cov8" title="1">goose.SetLogger(NewSlogLogger(logger))

        db := stdlib.OpenDBFromPool(pool)
        if err := goose.Up(db, config.DB.MigrationsPath); err != nil </span><span class="cov0" title="0">{
                logger.Error("goose: unable to run migrations", slog.Any("error", err))
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package txmngr

import (
        trmpgx "github.com/avito-tech/go-transaction-manager/drivers/pgxv5/v2"
        "github.com/avito-tech/go-transaction-manager/trm/v2/manager"
        "github.com/m11ano/avito-shop/internal/infra/db"
)

func NewProvider(dbpool db.PgxPool) func() (*manager.Manager, *trmpgx.CtxGetter) <span class="cov8" title="1">{
        return func() (*manager.Manager, *trmpgx.CtxGetter) </span><span class="cov8" title="1">{
                return New(dbpool)
        }</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package txmngr

import (
        trmpgx "github.com/avito-tech/go-transaction-manager/drivers/pgxv5/v2"
        "github.com/avito-tech/go-transaction-manager/trm/v2/manager"
        "github.com/avito-tech/go-transaction-manager/trm/v2/settings"
        "github.com/jackc/pgx/v5"
        "github.com/m11ano/avito-shop/internal/infra/db"
)

func New(dbpool db.PgxPool) (*manager.Manager, *trmpgx.CtxGetter) <span class="cov8" title="1">{
        txOptions := pgx.TxOptions{
                IsoLevel: pgx.RepeatableRead, // Устанавливаем уровень изоляции RepeatableRead
        }

        settingsOpts := settings.Must()

        trmpgxSettings := trmpgx.MustSettings(settingsOpts, trmpgx.WithTxOptions(txOptions))

        txFactory := trmpgx.NewFactory(dbpool)

        txManager := manager.Must(txFactory, manager.WithSettings(trmpgxSettings))

        return txManager, trmpgx.DefaultCtxGetter
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package repository

import (
        "context"
        "log/slog"
        "time"

        "github.com/Masterminds/squirrel"
        trmpgx "github.com/avito-tech/go-transaction-manager/drivers/pgxv5/v2"
        "github.com/georgysavva/scany/v2/pgxscan"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/m11ano/avito-shop/internal/domain"
        "github.com/m11ano/avito-shop/pkg/dbhelper"
        "github.com/m11ano/avito-shop/pkg/e"
)

const (
        accountTable = "account"
)

type DBAccount struct {
        ID           uuid.UUID `db:"account_id"`
        Username     string    `db:"username"`
        PasswordHash string    `db:"password_hash"`
        CreatedAt    time.Time `db:"created_at"`
        UpdatedAt    time.Time `db:"updated_at"`
}

var (
        accountTableFields = []string{}
        accountDBSchema    = &amp;DBAccount{}
)

func init() <span class="cov8" title="1">{
        accountTableFields = dbhelper.ExtractDBFields(accountDBSchema)
}</span>

type Account struct {
        logger *slog.Logger
        db     *pgxpool.Pool
        txc    *trmpgx.CtxGetter
        qb     squirrel.StatementBuilderType
}

func NewAccount(logger *slog.Logger, db *pgxpool.Pool, txc *trmpgx.CtxGetter) *Account <span class="cov8" title="1">{
        return &amp;Account{
                logger: logger,
                db:     db,
                txc:    txc,
                qb:     squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar),
        }
}</span>

func (r *Account) dbToDomain(db *DBAccount) *domain.Account <span class="cov8" title="1">{
        return &amp;domain.Account{
                ID:           db.ID,
                Username:     db.Username,
                PasswordHash: db.PasswordHash,
                CreatedAt:    db.CreatedAt,
                UpdatedAt:    db.UpdatedAt,
        }
}</span>

func (r *Account) FindItemByUsername(ctx context.Context, username string) (*domain.Account, error) <span class="cov8" title="1">{
        query, args, err := r.qb.Select(accountTableFields...).From(accountTable).Where(squirrel.Eq{"username": username}).Limit(1).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return nil, e.NewErrorFrom(e.ErrInternal).Wrap(err)
        }</span>

        <span class="cov8" title="1">rows, err := r.txc.DefaultTrOrDB(ctx, r.db).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov8" title="1">defer rows.Close()

        dbData := &amp;DBAccount{}

        if err := pgxscan.ScanOne(dbData, rows); err != nil </span><span class="cov8" title="1">{
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                }</span>
                <span class="cov8" title="1">return nil, convErr</span>
        }

        <span class="cov8" title="1">item := r.dbToDomain(dbData)

        return item, nil</span>
}

func (r *Account) FindItemsByIDs(ctx context.Context, ids []uuid.UUID) (map[uuid.UUID]domain.Account, error) <span class="cov8" title="1">{
        query, args, err := r.qb.Select(accountTableFields...).From(accountTable).Where(squirrel.Eq{"account_id": ids}).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return nil, e.NewErrorFrom(e.ErrInternal).Wrap(err)
        }</span>

        <span class="cov8" title="1">rows, err := r.txc.DefaultTrOrDB(ctx, r.db).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov8" title="1">defer rows.Close()

        result := map[uuid.UUID]domain.Account{}

        for rows.Next() </span><span class="cov8" title="1">{
                data := &amp;DBAccount{}
                if err := pgxscan.ScanRow(data, rows); err != nil </span><span class="cov0" title="0">{
                        errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                        if !errIsConv </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return nil, convErr</span>
                }
                <span class="cov8" title="1">domainItem := *r.dbToDomain(data)
                result[domainItem.ID] = domainItem</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

func (r *Account) Create(ctx context.Context, item *domain.Account) error <span class="cov8" title="1">{
        dataMap, err := dbhelper.StructToDBMap(item, accountDBSchema)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "convert struct to db map", slog.Any("error", err))
                return e.NewErrorFrom(e.ErrInternal).Wrap(err)
        }</span>
        <span class="cov8" title="1">dataMap["updated_at"] = time.Now()

        query, args, err := r.qb.Insert(accountTable).SetMap(dataMap).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return e.NewErrorFrom(e.ErrInternal).Wrap(err)
        }</span>

        <span class="cov8" title="1">_, err = r.txc.DefaultTrOrDB(ctx, r.db).Exec(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return convErr</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package repository

import (
        "context"
        "log/slog"
        "time"

        "github.com/Masterminds/squirrel"
        trmpgx "github.com/avito-tech/go-transaction-manager/drivers/pgxv5/v2"
        "github.com/georgysavva/scany/v2/pgxscan"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/m11ano/avito-shop/internal/domain"
        "github.com/m11ano/avito-shop/internal/usecase"
        "github.com/m11ano/avito-shop/pkg/dbhelper"
        "github.com/m11ano/avito-shop/pkg/e"
)

const (
        coinTransferTable = "coin_transfer"
)

type DBCoinTransfer struct {
        ID                    uuid.UUID               `db:"transfer_id"`
        Type                  domain.CoinTransferType `db:"transfer_type"`
        OwnerAccountID        uuid.UUID               `db:"owner_account_id"`
        CounterpartyAccountID uuid.UUID               `db:"counterparty_account_id"`
        Amount                int64                   `db:"amount"`
        CreatedAt             time.Time               `db:"created_at"`
        IdentityKey           *uuid.UUID              `db:"identity_key"`
}

var (
        //nolint:unused
        coinTransferTableFields = []string{}
        coinTransferDBSchema    = &amp;DBCoinTransfer{}
)

func init() <span class="cov8" title="1">{
        coinTransferTableFields = dbhelper.ExtractDBFields(coinTransferDBSchema)
}</span>

type CoinTransfer struct {
        logger *slog.Logger
        db     *pgxpool.Pool
        txc    *trmpgx.CtxGetter
        qb     squirrel.StatementBuilderType
}

func NewCoinTransfer(logger *slog.Logger, db *pgxpool.Pool, txc *trmpgx.CtxGetter) *CoinTransfer <span class="cov8" title="1">{
        return &amp;CoinTransfer{
                logger: logger,
                db:     db,
                txc:    txc,
                qb:     squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar),
        }
}</span>

//nolint:unused
func (r *CoinTransfer) dbToDomain(db *DBCoinTransfer) *domain.CoinTransfer <span class="cov0" title="0">{
        return &amp;domain.CoinTransfer{
                ID:                    db.ID,
                Type:                  db.Type,
                OwnerAccountID:        db.OwnerAccountID,
                CounterpartyAccountID: db.CounterpartyAccountID,
                Amount:                db.Amount,
                CreatedAt:             db.CreatedAt,
                IdentityKey:           db.IdentityKey,
        }
}</span>

type CoinTransferCheckIdentityDTO struct {
        Count int `db:"count"`
}

func (r *CoinTransfer) FindIdentity(ctx context.Context, key uuid.UUID) (bool, error) <span class="cov8" title="1">{
        query, args, err := r.qb.Select("COUNT(*) as count").From(coinTransferTable).Where(squirrel.Eq{"identity_key": key}).Limit(1).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return false, e.NewErrorFrom(e.ErrInternal).Wrap(err)
        }</span>

        <span class="cov8" title="1">rows, err := r.txc.DefaultTrOrDB(ctx, r.db).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return false, convErr</span>
        }

        <span class="cov8" title="1">defer rows.Close()

        dbData := &amp;CoinTransferCheckIdentityDTO{}

        if err := pgxscan.ScanOne(dbData, rows); err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return false, convErr</span>
        }

        <span class="cov8" title="1">return dbData.Count &gt; 0, nil</span>
}

func (r *CoinTransfer) Create(ctx context.Context, item *domain.CoinTransfer) error <span class="cov8" title="1">{
        dataMap, err := dbhelper.StructToDBMap(item, coinTransferDBSchema)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "convert struct to db map", slog.Any("error", err))
                return e.NewErrorFrom(e.ErrInternal).Wrap(err)
        }</span>

        <span class="cov8" title="1">query, args, err := r.qb.Insert(coinTransferTable).SetMap(dataMap).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return e.NewErrorFrom(e.ErrInternal).Wrap(err)
        }</span>

        <span class="cov8" title="1">_, err = r.txc.DefaultTrOrDB(ctx, r.db).Exec(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return convErr</span>
        }

        <span class="cov8" title="1">return nil</span>
}

type CoinTransferAggrCoinHistoryItem struct {
        AccountID   uuid.UUID `db:"counterparty_account_id"`
        TotalAmount int64     `db:"total_amount"`
}

func (r *CoinTransfer) GetAggrCoinHistoryByAccountID(ctx context.Context, accountID uuid.UUID, transferType domain.CoinTransferType) ([]usecase.CoinTransferRepositoryAggrHistoryItem, error) <span class="cov8" title="1">{
        query, args, err := r.qb.Select("counterparty_account_id", "SUM(amount) as total_amount").From(coinTransferTable).Where(squirrel.Eq{"owner_account_id": accountID, "transfer_type": transferType}).GroupBy("counterparty_account_id").ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return nil, e.NewErrorFrom(e.ErrInternal).Wrap(err)
        }</span>

        <span class="cov8" title="1">rows, err := r.txc.DefaultTrOrDB(ctx, r.db).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov8" title="1">defer rows.Close()

        result := make([]usecase.CoinTransferRepositoryAggrHistoryItem, 0)

        for rows.Next() </span><span class="cov8" title="1">{
                data := CoinTransferAggrCoinHistoryItem{}
                if err := pgxscan.ScanRow(&amp;data, rows); err != nil </span><span class="cov0" title="0">{
                        errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                        if !errIsConv </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return nil, convErr</span>
                }
                <span class="cov8" title="1">result = append(result, usecase.CoinTransferRepositoryAggrHistoryItem{
                        AccountID: data.AccountID,
                        Amount:    data.TotalAmount,
                })</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package repository

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "time"

        "github.com/Masterminds/squirrel"
        trmpgx "github.com/avito-tech/go-transaction-manager/drivers/pgxv5/v2"
        "github.com/avito-tech/go-transaction-manager/trm/v2/manager"
        "github.com/georgysavva/scany/v2/pgxscan"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/m11ano/avito-shop/internal/domain"
        "github.com/m11ano/avito-shop/pkg/dbhelper"
        "github.com/m11ano/avito-shop/pkg/e"
)

const (
        operationTable        = "operation"
        operationBalanceTable = "operation_balance"
)

type DBOperation struct {
        ID         uuid.UUID                  `db:"operation_id"`
        Type       domain.OperationType       `db:"operation_type"`
        AccountID  uuid.UUID                  `db:"account_id"`
        Amount     int64                      `db:"amount"`
        SourceType domain.OperationSourceType `db:"source_type"`
        SourceID   *uuid.UUID                 `db:"source_id"`
        CreatedAt  time.Time                  `db:"created_at"`
}

var (
        //nolint:unused
        operationTableFields = []string{}
        operationDBSchema    = &amp;DBOperation{}
)

func init() <span class="cov8" title="1">{
        operationTableFields = dbhelper.ExtractDBFields(operationDBSchema)
}</span>

type Operation struct {
        logger    *slog.Logger
        db        *pgxpool.Pool
        txc       *trmpgx.CtxGetter
        qb        squirrel.StatementBuilderType
        txManager *manager.Manager
}

func NewOperation(logger *slog.Logger, db *pgxpool.Pool, txc *trmpgx.CtxGetter, txManager *manager.Manager) *Operation <span class="cov8" title="1">{
        return &amp;Operation{
                logger:    logger,
                db:        db,
                txc:       txc,
                qb:        squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar),
                txManager: txManager,
        }
}</span>

//nolint:unused
func (r *Operation) dbToDomain(db *DBOperation) *domain.Operation <span class="cov0" title="0">{
        item := &amp;domain.Operation{
                ID:         db.ID,
                Type:       db.Type,
                AccountID:  db.AccountID,
                Amount:     db.Amount,
                SourceType: db.SourceType,
                SourceID:   db.SourceID,
                CreatedAt:  db.CreatedAt,
        }
        if item.Type == domain.OperationTypeDecrease </span><span class="cov0" title="0">{
                item.Amount = -item.Amount
        }</span>
        <span class="cov0" title="0">return item</span>
}

func (r *Operation) domainToDB(item *domain.Operation) (map[string]interface{}, error) <span class="cov8" title="1">{
        dataMap, err := dbhelper.StructToDBMap(item, operationDBSchema)
        if err != nil </span><span class="cov0" title="0">{
                return nil, e.NewErrorFrom(e.ErrInternal).Wrap(err)
        }</span>

        <span class="cov8" title="1">if item.Type == domain.OperationTypeDecrease </span><span class="cov8" title="1">{
                dataMap["amount"] = -item.Amount
        }</span>

        <span class="cov8" title="1">return dataMap, nil</span>
}

type OperationGetBalanceDTO struct {
        Balance int64 `db:"balance"`
}

func (r *Operation) GetBalanceByAccountID(ctx context.Context, accountID uuid.UUID) (int64, bool, error) <span class="cov8" title="1">{
        query, args, err := r.qb.Select("balance").From(operationBalanceTable).Where(squirrel.Eq{"account_id": accountID}).Limit(1).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return 0, false, e.NewErrorFrom(e.ErrInternal).Wrap(err)
        }</span>

        <span class="cov8" title="1">rows, err := r.txc.DefaultTrOrDB(ctx, r.db).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return 0, false, convErr</span>
        }

        <span class="cov8" title="1">defer rows.Close()

        dbData := &amp;OperationGetBalanceDTO{}

        if err := pgxscan.ScanOne(dbData, rows); err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">if errors.Is(convErr, e.ErrStoreNoRows) </span><span class="cov0" title="0">{
                        return 0, false, nil
                }</span>
                <span class="cov0" title="0">return 0, false, convErr</span>
        }

        <span class="cov8" title="1">return dbData.Balance, true, nil</span>
}

// Внутренний метод, обновить баланс по логу операций
func (r *Operation) updateBalanceByAccountID(ctx context.Context, accountID uuid.UUID) error <span class="cov8" title="1">{
        updateQuery := squirrel.Expr("INSERT INTO operation_balance (account_id, balance) VALUES ($1, (SELECT COALESCE(SUM(amount), 0) FROM operation WHERE account_id = $1)) ON CONFLICT (account_id) DO UPDATE SET balance = (SELECT COALESCE(SUM(amount), 0) FROM operation WHERE account_id = $1)", accountID)

        query, args, err := updateQuery.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return e.NewErrorFrom(e.ErrInternal).Wrap(err)
        }</span>

        <span class="cov8" title="1">rows, err := r.txc.DefaultTrOrDB(ctx, r.db).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("CATCH")
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return convErr</span>
        }

        <span class="cov8" title="1">defer rows.Close()

        return nil</span>
}

func (r *Operation) Create(ctx context.Context, item *domain.Operation) (int64, error) <span class="cov8" title="1">{
        dataMap, err := r.domainToDB(item)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "convert struct to db map", slog.Any("error", err))
                return 0, err
        }</span>

        <span class="cov8" title="1">var balance int64

        // DOTO: подумать целесообразности ретраев при возникновении блокировки
        err = r.txManager.Do(ctx, func(ctx context.Context) error </span><span class="cov8" title="1">{
                query, args, err := r.qb.Insert(operationTable).SetMap(dataMap).ToSql()
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                        return e.NewErrorFrom(e.ErrInternal).Wrap(err)
                }</span>

                <span class="cov8" title="1">_, err = r.txc.DefaultTrOrDB(ctx, r.db).Exec(ctx, query, args...)
                if err != nil </span><span class="cov0" title="0">{
                        errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                        if !errIsConv </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return convErr</span>
                }

                // Если две конкурирующие транзакции попытаются обновить баланс аккаунта - одна из них получит блокировку
                <span class="cov8" title="1">err = r.updateBalanceByAccountID(ctx, item.AccountID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Далее если транзакция получила блокировку, здесь при попытке чтения вызовется ошибка
                <span class="cov8" title="1">balance, _, err = r.GetBalanceByAccountID(ctx, item.AccountID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return balance, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package repository

import (
        "context"
        "log/slog"

        "github.com/Masterminds/squirrel"
        trmpgx "github.com/avito-tech/go-transaction-manager/drivers/pgxv5/v2"
        "github.com/georgysavva/scany/v2/pgxscan"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/m11ano/avito-shop/internal/domain"
        "github.com/m11ano/avito-shop/pkg/dbhelper"
        "github.com/m11ano/avito-shop/pkg/e"
)

const (
        shopItemTable = "shop_item"
)

type DBShopItem struct {
        ID    uuid.UUID `db:"item_id"`
        Name  string    `db:"item_name"`
        Price int64     `db:"price"`
}

var (
        shopItemTableFields = []string{}
        shopItemDBSchema    = &amp;DBShopItem{}
)

func init() <span class="cov8" title="1">{
        shopItemTableFields = dbhelper.ExtractDBFields(shopItemDBSchema)
}</span>

type ShopItem struct {
        logger *slog.Logger
        db     *pgxpool.Pool
        txc    *trmpgx.CtxGetter
        qb     squirrel.StatementBuilderType
}

func NewShopItem(logger *slog.Logger, db *pgxpool.Pool, txc *trmpgx.CtxGetter) *ShopItem <span class="cov8" title="1">{
        return &amp;ShopItem{
                logger: logger,
                db:     db,
                txc:    txc,
                qb:     squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar),
        }
}</span>

func (r *ShopItem) dbToDomain(db *DBShopItem) *domain.ShopItem <span class="cov8" title="1">{
        return &amp;domain.ShopItem{
                ID:    db.ID,
                Name:  db.Name,
                Price: db.Price,
        }
}</span>

func (r *ShopItem) FindItemByID(ctx context.Context, id uuid.UUID) (*domain.ShopItem, error) <span class="cov0" title="0">{
        query, args, err := r.qb.Select(shopItemTableFields...).From(shopItemTable).Where(squirrel.Eq{"item_id": id}).Limit(1).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return nil, e.NewErrorFrom(e.ErrInternal).Wrap(err)
        }</span>

        <span class="cov0" title="0">rows, err := r.txc.DefaultTrOrDB(ctx, r.db).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov0" title="0">defer rows.Close()

        dbData := &amp;DBShopItem{}

        if err := pgxscan.ScanOne(dbData, rows); err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov0" title="0">item := r.dbToDomain(dbData)

        return item, nil</span>
}

func (r *ShopItem) FindItemByName(ctx context.Context, name string) (*domain.ShopItem, error) <span class="cov8" title="1">{
        query, args, err := r.qb.Select(shopItemTableFields...).From(shopItemTable).Where(squirrel.Eq{"item_name": name}).Limit(1).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return nil, e.NewErrorFrom(e.ErrInternal).Wrap(err)
        }</span>

        <span class="cov8" title="1">rows, err := r.txc.DefaultTrOrDB(ctx, r.db).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov8" title="1">defer rows.Close()

        dbData := &amp;DBShopItem{}

        if err := pgxscan.ScanOne(dbData, rows); err != nil </span><span class="cov8" title="1">{
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                }</span>
                <span class="cov8" title="1">return nil, convErr</span>
        }

        <span class="cov8" title="1">item := r.dbToDomain(dbData)

        return item, nil</span>
}

func (r *ShopItem) FindItemsByIDs(ctx context.Context, ids []uuid.UUID) (map[uuid.UUID]domain.ShopItem, error) <span class="cov8" title="1">{
        query, args, err := r.qb.Select(shopItemTableFields...).From(shopItemTable).Where(squirrel.Eq{"item_id": ids}).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return nil, e.NewErrorFrom(e.ErrInternal).Wrap(err)
        }</span>

        <span class="cov8" title="1">rows, err := r.txc.DefaultTrOrDB(ctx, r.db).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov8" title="1">defer rows.Close()

        result := map[uuid.UUID]domain.ShopItem{}

        for rows.Next() </span><span class="cov8" title="1">{
                data := &amp;DBShopItem{}
                if err := pgxscan.ScanRow(data, rows); err != nil </span><span class="cov0" title="0">{
                        errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                        if !errIsConv </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return nil, convErr</span>
                }
                <span class="cov8" title="1">domainItem := *r.dbToDomain(data)
                result[domainItem.ID] = domainItem</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package repository

import (
        "context"
        "log/slog"
        "time"

        "github.com/Masterminds/squirrel"
        trmpgx "github.com/avito-tech/go-transaction-manager/drivers/pgxv5/v2"
        "github.com/georgysavva/scany/v2/pgxscan"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/m11ano/avito-shop/internal/domain"
        "github.com/m11ano/avito-shop/internal/usecase"
        "github.com/m11ano/avito-shop/pkg/dbhelper"
        "github.com/m11ano/avito-shop/pkg/e"
)

const (
        shopPurchaseTable = "shop_purchase"
)

type DBShopPurchase struct {
        ID          uuid.UUID  `db:"purchase_id"`
        ItemID      uuid.UUID  `db:"item_id"`
        AccountID   uuid.UUID  `db:"account_id"`
        Quantity    int64      `db:"quantity"`
        CreatedAt   time.Time  `db:"created_at"`
        IdentityKey *uuid.UUID `db:"identity_key"`
}

var (
        //nolint:unused
        shopPurchaseTableFields = []string{}
        shopPurchaseDBSchema    = &amp;DBShopPurchase{}
)

func init() <span class="cov8" title="1">{
        shopPurchaseTableFields = dbhelper.ExtractDBFields(shopPurchaseDBSchema)
}</span>

type ShopPurchase struct {
        logger *slog.Logger
        db     *pgxpool.Pool
        txc    *trmpgx.CtxGetter
        qb     squirrel.StatementBuilderType
}

func NewShopPurchase(logger *slog.Logger, db *pgxpool.Pool, txc *trmpgx.CtxGetter) *ShopPurchase <span class="cov8" title="1">{
        return &amp;ShopPurchase{
                logger: logger,
                db:     db,
                txc:    txc,
                qb:     squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar),
        }
}</span>

//nolint:unused
func (r *ShopPurchase) dbToDomain(db *DBShopPurchase) *domain.ShopPurchase <span class="cov0" title="0">{
        return &amp;domain.ShopPurchase{
                ID:          db.ID,
                ItemID:      db.ItemID,
                AccountID:   db.AccountID,
                Quantity:    db.Quantity,
                CreatedAt:   db.CreatedAt,
                IdentityKey: db.IdentityKey,
        }
}</span>

type ShopPurchaseCheckIdentityDTO struct {
        Count int `db:"count"`
}

func (r *ShopPurchase) FindIdentity(ctx context.Context, key uuid.UUID) (bool, error) <span class="cov8" title="1">{
        query, args, err := r.qb.Select("COUNT(*) as count").From(shopPurchaseTable).Where(squirrel.Eq{"identity_key": key}).Limit(1).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return false, e.NewErrorFrom(e.ErrInternal).Wrap(err)
        }</span>

        <span class="cov8" title="1">rows, err := r.txc.DefaultTrOrDB(ctx, r.db).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return false, convErr</span>
        }

        <span class="cov8" title="1">defer rows.Close()

        dbData := &amp;ShopPurchaseCheckIdentityDTO{}

        if err := pgxscan.ScanOne(dbData, rows); err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return false, convErr</span>
        }

        <span class="cov8" title="1">return dbData.Count &gt; 0, nil</span>
}

func (r *ShopPurchase) Create(ctx context.Context, item *domain.ShopPurchase) error <span class="cov8" title="1">{
        dataMap, err := dbhelper.StructToDBMap(item, shopPurchaseDBSchema)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "convert struct to db map", slog.Any("error", err))
                return e.NewErrorFrom(e.ErrInternal).Wrap(err)
        }</span>

        <span class="cov8" title="1">query, args, err := r.qb.Insert(shopPurchaseTable).SetMap(dataMap).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return e.NewErrorFrom(e.ErrInternal).Wrap(err)
        }</span>

        <span class="cov8" title="1">_, err = r.txc.DefaultTrOrDB(ctx, r.db).Exec(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return convErr</span>
        }

        <span class="cov8" title="1">return nil</span>
}

type ShopPurchaseAggrInventoryItem struct {
        ItemID        uuid.UUID `db:"item_id"`
        TotalQuantity int64     `db:"total_quantity"`
}

func (r *ShopPurchase) AggrInventoryByAccountID(ctx context.Context, accountID uuid.UUID) ([]usecase.ShopPurchaseRepositoryAggrInventoryItem, error) <span class="cov8" title="1">{
        query, args, err := r.qb.Select("item_id", "SUM(quantity) as total_quantity").From(shopPurchaseTable).Where(squirrel.Eq{"account_id": accountID}).GroupBy("item_id").ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return nil, e.NewErrorFrom(e.ErrInternal).Wrap(err)
        }</span>

        <span class="cov8" title="1">rows, err := r.txc.DefaultTrOrDB(ctx, r.db).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov8" title="1">defer rows.Close()

        result := make([]usecase.ShopPurchaseRepositoryAggrInventoryItem, 0)

        for rows.Next() </span><span class="cov8" title="1">{
                data := ShopPurchaseAggrInventoryItem{}
                if err := pgxscan.ScanRow(&amp;data, rows); err != nil </span><span class="cov0" title="0">{
                        errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                        if !errIsConv </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return nil, convErr</span>
                }
                <span class="cov8" title="1">result = append(result, usecase.ShopPurchaseRepositoryAggrInventoryItem{
                        ShopItemID: data.ItemID,
                        Quantity:   data.TotalQuantity,
                })</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := e.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package usecase

import (
        "context"
        "log/slog"

        "github.com/avito-tech/go-transaction-manager/trm/v2/manager"
        "github.com/google/uuid"
        "github.com/m11ano/avito-shop/internal/domain"
        "github.com/m11ano/avito-shop/internal/infra/config"
)

//go:generate mockery --name=Account --output=../../tests/mocks --case=underscore
type Account interface {
        GetItemByUsername(ctx context.Context, username string) (account *domain.Account, err error)
        GetItemsByIDs(ctx context.Context, ids []uuid.UUID) (accounts map[uuid.UUID]domain.Account, err error)
        Create(ctx context.Context, account *domain.Account) error
}

//go:generate mockery --name=AccountRepository --output=../../tests/mocks --case=underscore
type AccountRepository interface {
        FindItemByUsername(ctx context.Context, username string) (account *domain.Account, err error)
        FindItemsByIDs(ctx context.Context, ids []uuid.UUID) (accounts map[uuid.UUID]domain.Account, err error)
        Create(ctx context.Context, account *domain.Account) error
}

type AccountInpl struct {
        logger    *slog.Logger
        config    config.Config
        repo      AccountRepository
        txManager *manager.Manager
}

func NewAccountInpl(logger *slog.Logger, config config.Config, txManager *manager.Manager, repo AccountRepository) *AccountInpl <span class="cov8" title="1">{
        uc := &amp;AccountInpl{
                logger:    logger,
                config:    config,
                txManager: txManager,
                repo:      repo,
        }
        return uc
}</span>

func (uc *AccountInpl) GetItemByUsername(ctx context.Context, username string) (*domain.Account, error) <span class="cov8" title="1">{
        return uc.repo.FindItemByUsername(ctx, username)
}</span>

func (uc *AccountInpl) GetItemsByIDs(ctx context.Context, ids []uuid.UUID) (map[uuid.UUID]domain.Account, error) <span class="cov8" title="1">{
        return uc.repo.FindItemsByIDs(ctx, ids)
}</span>

func (uc *AccountInpl) Create(ctx context.Context, item *domain.Account) error <span class="cov8" title="1">{
        return uc.repo.Create(ctx, item)
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package usecase

import (
        "context"
        "errors"
        "log/slog"
        "strconv"
        "time"

        "github.com/avito-tech/go-transaction-manager/trm/v2/manager"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "github.com/m11ano/avito-shop/internal/domain"
        "github.com/m11ano/avito-shop/internal/infra/config"
        "github.com/m11ano/avito-shop/pkg/e"
)

//go:generate mockery --name=Auth --output=../../tests/mocks --case=underscore
type Auth interface {
        SignInOrSignUp(ctx context.Context, username string, password string) (jwtToken string, err error)
        AuthByJWTToken(ctx context.Context, jwtToken string) (accountID *uuid.UUID, err error)
}

type AuthInpl struct {
        logger           *slog.Logger
        config           config.Config
        txManager        *manager.Manager
        usecaseAccount   Account
        usecaseOperation Operation
}

func NewAuthInpl(logger *slog.Logger, config config.Config, txManager *manager.Manager, usecaseAccount Account, usecaseOperation Operation) *AuthInpl <span class="cov8" title="1">{
        uc := &amp;AuthInpl{
                logger:           logger,
                config:           config,
                txManager:        txManager,
                usecaseAccount:   usecaseAccount,
                usecaseOperation: usecaseOperation,
        }
        return uc
}</span>

func (uc *AuthInpl) generateJWTToken(ctx context.Context, account *domain.Account) (string, error) <span class="cov8" title="1">{
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "accountID": account.ID.String(),
                "createdAt": strconv.FormatInt(time.Now().Unix(), 10),
        })

        tokenStr, err := token.SignedString([]byte(uc.config.Auth.JWTSecretKey))
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.ErrorContext(ctx, "jwt sign error", slog.Any("error", err))
                return "", e.NewErrorFrom(e.ErrInternal).Wrap(err)
        }</span>

        <span class="cov8" title="1">return tokenStr, nil</span>
}

func (uc *AuthInpl) SignInOrSignUp(ctx context.Context, username string, password string) (string, error) <span class="cov8" title="1">{
        var account *domain.Account
        var err error

        err = uc.txManager.Do(ctx, func(ctx context.Context) error </span><span class="cov8" title="1">{
                account, err = uc.usecaseAccount.GetItemByUsername(ctx, username)
                if err != nil &amp;&amp; errors.Is(err, e.ErrNotFound) </span><span class="cov8" title="1">{
                        account, err = domain.NewAccount(username, password)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">err = uc.usecaseAccount.Create(ctx, account)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if uc.config.Auth.NewAccountAmount &gt; 0 </span><span class="cov8" title="1">{
                                depositOp := domain.NewOperation(domain.OperationTypeIncrease, account.ID, uc.config.Auth.NewAccountAmount, domain.OperationSourceTypeDeposit, nil)
                                _, err := uc.usecaseOperation.SaveOperation(ctx, depositOp)
                                if err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                        }
                } else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if !e.IsAppError(err) </span><span class="cov8" title="1">{
                        return "", e.NewErrorFrom(e.ErrInternal).Wrap(err)
                }</span>
                <span class="cov8" title="1">return "", err</span>
        }

        <span class="cov8" title="1">check := account.VerifyPassword(password)
        if !check </span><span class="cov8" title="1">{
                return "", e.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">return uc.generateJWTToken(ctx, account)</span>
}

func (uc *AuthInpl) AuthByJWTToken(ctx context.Context, tokenStr string) (*uuid.UUID, error) <span class="cov8" title="1">{
        claims := jwt.MapClaims{}
        token, err := jwt.ParseWithClaims(tokenStr, claims, func(_ *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                return []byte(uc.config.Auth.JWTSecretKey), nil
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                uc.logger.ErrorContext(ctx, "parse jwt", slog.Any("error", err))
                return nil, e.NewErrorFrom(e.ErrUnauthorized).Wrap(err)
        }</span>

        <span class="cov8" title="1">if !token.Valid </span><span class="cov0" title="0">{
                return nil, e.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">var accountIDStr string
        var createdAtStr string
        var createdAt int64
        var ok bool

        if accountIDStr, ok = claims["accountID"].(string); !ok </span><span class="cov8" title="1">{
                return nil, e.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">if createdAtStr, ok = claims["createdAt"].(string); !ok </span><span class="cov8" title="1">{
                return nil, e.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">createdAt, err = strconv.ParseInt(createdAtStr, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return nil, e.NewErrorFrom(e.ErrUnauthorized).Wrap(err)
        }</span>

        <span class="cov8" title="1">accountID, err := uuid.Parse(accountIDStr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, e.NewErrorFrom(e.ErrUnauthorized).Wrap(err)
        }</span>

        <span class="cov8" title="1">if time.Now().Unix()-createdAt &gt; uc.config.Auth.JWTTokenTTL </span><span class="cov8" title="1">{
                return nil, e.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">return &amp;accountID, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package usecase

import (
        "context"
        "log/slog"

        "github.com/avito-tech/go-transaction-manager/trm/v2/manager"
        "github.com/google/uuid"
        "github.com/m11ano/avito-shop/internal/domain"
        "github.com/m11ano/avito-shop/internal/infra/config"
        "github.com/m11ano/avito-shop/pkg/e"
)

var ErrCoinTransferAmountMustBeGreaterThanZero = e.NewErrorFrom(e.ErrBadRequest).SetMessage("amount must be greater than zero")

type CoinTransferGetAggrHistoryItem struct {
        Account *domain.Account
        Amount  int64
}

//go:generate mockery --name=CoinTransfer --output=../../tests/mocks --case=underscore
type CoinTransfer interface {
        MakeTransferByUsername(ctx context.Context, targetAccountUsername string, ownerAccountID uuid.UUID, amount int64, identityKey *uuid.UUID) (ownerCoinTransfer *domain.CoinTransfer, targetCoinTransfer *domain.CoinTransfer, err error)
        GetAggrCoinHistory(ctx context.Context, accountID uuid.UUID, transferType domain.CoinTransferType) (aggrHistory []CoinTransferGetAggrHistoryItem, err error)
}

type CoinTransferRepositoryAggrHistoryItem struct {
        AccountID uuid.UUID
        Amount    int64
}

//go:generate mockery --name=CoinTransferRepository --output=../../tests/mocks --case=underscore
type CoinTransferRepository interface {
        FindIdentity(ctx context.Context, identityKey uuid.UUID) (found bool, err error)
        Create(ctx context.Context, coinTransfer *domain.CoinTransfer) error
        GetAggrCoinHistoryByAccountID(ctx context.Context, accountID uuid.UUID, transferType domain.CoinTransferType) (aggrHistory []CoinTransferRepositoryAggrHistoryItem, err error)
}

type CoinTransferInpl struct {
        logger           *slog.Logger
        config           config.Config
        repo             CoinTransferRepository
        txManager        *manager.Manager
        usecaseAccount   Account
        usecaseOperation Operation
}

func NewCoinTransferInpl(logger *slog.Logger, config config.Config, txManager *manager.Manager, repo CoinTransferRepository, usecaseAccount Account, usecaseOperation Operation) *CoinTransferInpl <span class="cov8" title="1">{
        uc := &amp;CoinTransferInpl{
                logger:           logger,
                config:           config,
                txManager:        txManager,
                repo:             repo,
                usecaseAccount:   usecaseAccount,
                usecaseOperation: usecaseOperation,
        }
        return uc
}</span>

// Make coin transfer from owner to target
func (uc *CoinTransferInpl) MakeTransferByUsername(ctx context.Context, targetAccountUsername string, ownerAccountID uuid.UUID, amount int64, identityKey *uuid.UUID) (*domain.CoinTransfer, *domain.CoinTransfer, error) <span class="cov8" title="1">{
        var err error
        var transferForOwner *domain.CoinTransfer
        var transferForTarget *domain.CoinTransfer

        if amount &lt;= 0 </span><span class="cov8" title="1">{
                return nil, nil, ErrCoinTransferAmountMustBeGreaterThanZero
        }</span>

        <span class="cov8" title="1">err = uc.txManager.Do(ctx, func(ctx context.Context) error </span><span class="cov8" title="1">{
                if identityKey != nil </span><span class="cov8" title="1">{
                        isIdentityExists, err := uc.repo.FindIdentity(ctx, *identityKey)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if isIdentityExists </span><span class="cov8" title="1">{
                                return e.ErrConflict
                        }</span>
                }

                <span class="cov8" title="1">targetAccount, err := uc.usecaseAccount.GetItemByUsername(ctx, targetAccountUsername)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">if targetAccount.ID == ownerAccountID </span><span class="cov8" title="1">{
                        return e.NewErrorFrom(e.ErrConflict).SetMessage("cant send coin to yourself")
                }</span>

                <span class="cov8" title="1">transferForOwner = domain.NewCoinTransfer(domain.CoinTransferTypeSending, targetAccount.ID, ownerAccountID, amount, identityKey)
                transferForTarget = domain.NewCoinTransfer(domain.CoinTransferTypeReciving, ownerAccountID, targetAccount.ID, amount, identityKey)

                operationForOwner := domain.NewOperation(domain.OperationTypeDecrease, ownerAccountID, amount, domain.OperationSourceTypeTransfer, &amp;transferForOwner.ID)
                operationForTarget := domain.NewOperation(domain.OperationTypeIncrease, targetAccount.ID, amount, domain.OperationSourceTypeTransfer, &amp;transferForTarget.ID)

                _, err = uc.usecaseOperation.SaveOperation(ctx, operationForOwner)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">_, err = uc.usecaseOperation.SaveOperation(ctx, operationForTarget)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">err = uc.repo.Create(ctx, transferForOwner)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">err = uc.repo.Create(ctx, transferForTarget)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if !e.IsAppError(err) </span><span class="cov8" title="1">{
                        return nil, nil, e.NewErrorFrom(e.ErrInternal).Wrap(err)
                }</span>
                <span class="cov8" title="1">return nil, nil, err</span>
        }

        <span class="cov8" title="1">return transferForOwner, transferForTarget, nil</span>
}

func (uc *CoinTransferInpl) GetAggrCoinHistory(ctx context.Context, accountID uuid.UUID, transferType domain.CoinTransferType) ([]CoinTransferGetAggrHistoryItem, error) <span class="cov8" title="1">{
        history, err := uc.repo.GetAggrCoinHistoryByAccountID(ctx, accountID, transferType)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">accountIDs := make([]uuid.UUID, 0, len(history))
        for _, item := range history </span><span class="cov8" title="1">{
                accountIDs = append(accountIDs, item.AccountID)
        }</span>

        <span class="cov8" title="1">accountItems, err := uc.usecaseAccount.GetItemsByIDs(ctx, accountIDs)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := make([]CoinTransferGetAggrHistoryItem, 0, len(history))

        for _, item := range history </span><span class="cov8" title="1">{
                resultItem := CoinTransferGetAggrHistoryItem{
                        Amount: item.Amount,
                }
                if accountItem, ok := accountItems[item.AccountID]; ok </span><span class="cov8" title="1">{
                        resultItem.Account = &amp;accountItem
                }</span>

                <span class="cov8" title="1">result = append(result, resultItem)</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package usecase

import (
        "context"
        "log/slog"

        "github.com/avito-tech/go-transaction-manager/trm/v2/manager"
        "github.com/google/uuid"
        "github.com/m11ano/avito-shop/internal/domain"
        "github.com/m11ano/avito-shop/internal/infra/config"
        "github.com/m11ano/avito-shop/pkg/e"
)

var ErrOperationNotEnoughFunds = e.NewErrorFrom(e.ErrUnprocessableEntity).SetMessage("not enough funds")

//go:generate mockery --name=Operation --output=../../tests/mocks --case=underscore
type Operation interface {
        GetBalanceByAccountID(ctx context.Context, accountID uuid.UUID) (balance int64, found bool, err error)
        SaveOperation(ctx context.Context, operation *domain.Operation) (balance int64, err error)
}

//go:generate mockery --name=OperationRepository --output=../../tests/mocks --case=underscore
type OperationRepository interface {
        GetBalanceByAccountID(ctx context.Context, accountID uuid.UUID) (balance int64, found bool, err error)
        Create(ctx context.Context, operation *domain.Operation) (balance int64, err error)
}

type OperationInpl struct {
        logger    *slog.Logger
        config    config.Config
        repo      OperationRepository
        txManager *manager.Manager
}

func NewOperationInpl(logger *slog.Logger, config config.Config, txManager *manager.Manager, repo OperationRepository) *OperationInpl <span class="cov8" title="1">{
        uc := &amp;OperationInpl{
                logger:    logger,
                config:    config,
                txManager: txManager,
                repo:      repo,
        }
        return uc
}</span>

func (uc *OperationInpl) SaveOperation(ctx context.Context, operation *domain.Operation) (int64, error) <span class="cov8" title="1">{
        var err error
        var balance int64
        switch operation.Type </span>{
        case domain.OperationTypeDecrease:<span class="cov8" title="1">
                // Если списание - проверим баланс в транзакции и если меньше 0 - откатим принудительно и вернем ошибку
                err = uc.txManager.Do(ctx, func(ctx context.Context) error </span><span class="cov8" title="1">{
                        balance, err = uc.repo.Create(ctx, operation)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if balance &lt; 0 </span><span class="cov8" title="1">{
                                return ErrOperationNotEnoughFunds
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                })
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        return 0, err
                }</span>
        case domain.OperationTypeIncrease:<span class="cov8" title="1">
                // Если пополнение - просто сохраняем
                balance, err = uc.repo.Create(ctx, operation)
                if err != nil </span><span class="cov8" title="1">{
                        return 0, err
                }</span>
        }

        <span class="cov8" title="1">return balance, nil</span>
}

func (uc *OperationInpl) GetBalanceByAccountID(ctx context.Context, accountID uuid.UUID) (int64, bool, error) <span class="cov8" title="1">{
        return uc.repo.GetBalanceByAccountID(ctx, accountID)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package usecase

import (
        "context"

        "github.com/google/uuid"
        "github.com/m11ano/avito-shop/internal/domain"
)

//go:generate mockery --name=ShopItem --output=../../tests/mocks --case=underscore
type ShopItem interface {
        GetItemByID(ctx context.Context, id uuid.UUID) (shopItem *domain.ShopItem, err error)
        GetItemByName(ctx context.Context, name string) (shopItem *domain.ShopItem, err error)
        GetItemsByIDs(ctx context.Context, ids []uuid.UUID) (shopItems map[uuid.UUID]domain.ShopItem, err error)
}

//go:generate mockery --name=ShopItemRepository --output=../../tests/mocks --case=underscore
type ShopItemRepository interface {
        FindItemByID(ctx context.Context, id uuid.UUID) (shopItem *domain.ShopItem, err error)
        FindItemByName(ctx context.Context, name string) (shopItem *domain.ShopItem, err error)
        FindItemsByIDs(ctx context.Context, ids []uuid.UUID) (shopItems map[uuid.UUID]domain.ShopItem, err error)
}

type ShopItemInpl struct {
        repo ShopItemRepository
}

func NewShopItemInpl(repo ShopItemRepository) *ShopItemInpl <span class="cov8" title="1">{
        uc := &amp;ShopItemInpl{
                repo: repo,
        }
        return uc
}</span>

func (uc *ShopItemInpl) GetItemByID(ctx context.Context, id uuid.UUID) (*domain.ShopItem, error) <span class="cov8" title="1">{
        return uc.repo.FindItemByID(ctx, id)
}</span>

func (uc *ShopItemInpl) GetItemByName(ctx context.Context, name string) (*domain.ShopItem, error) <span class="cov8" title="1">{
        return uc.repo.FindItemByName(ctx, name)
}</span>

func (uc *ShopItemInpl) GetItemsByIDs(ctx context.Context, ids []uuid.UUID) (map[uuid.UUID]domain.ShopItem, error) <span class="cov8" title="1">{
        return uc.repo.FindItemsByIDs(ctx, ids)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package usecase

import (
        "context"
        "log/slog"

        "github.com/avito-tech/go-transaction-manager/trm/v2/manager"
        "github.com/google/uuid"
        "github.com/m11ano/avito-shop/internal/domain"
        "github.com/m11ano/avito-shop/internal/infra/config"
        "github.com/m11ano/avito-shop/pkg/e"
)

type ShopPurchaseGetInventoryItem struct {
        ShopItem *domain.ShopItem
        Quantity int64
}

//go:generate mockery --name=ShopPurchase --output=../../tests/mocks --case=underscore
type ShopPurchase interface {
        MakePurchase(ctx context.Context, shopItemName string, ownerAccountID uuid.UUID, quantity int64, identityKey *uuid.UUID) (shopPurchase *domain.ShopPurchase, err error)
        GetInventory(ctx context.Context, accountID uuid.UUID) (inventory []ShopPurchaseGetInventoryItem, err error)
}

type ShopPurchaseRepositoryAggrInventoryItem struct {
        ShopItemID uuid.UUID
        Quantity   int64
}

//go:generate mockery --name=ShopPurchaseRepository --output=../../tests/mocks --case=underscore
type ShopPurchaseRepository interface {
        FindIdentity(ctx context.Context, identityKey uuid.UUID) (found bool, err error)
        Create(ctx context.Context, shopPurchase *domain.ShopPurchase) error
        AggrInventoryByAccountID(ctx context.Context, accountID uuid.UUID) (inventory []ShopPurchaseRepositoryAggrInventoryItem, err error)
}

type ShopPurchaseInpl struct {
        logger           *slog.Logger
        config           config.Config
        repo             ShopPurchaseRepository
        txManager        *manager.Manager
        usecaseAccount   Account
        usecaseOperation Operation
        usecaseShopItem  ShopItem
}

func NewShopPurchaseInpl(logger *slog.Logger, config config.Config, txManager *manager.Manager, repo ShopPurchaseRepository, usecaseAccount Account, usecaseOperation Operation, usecaseShopItem ShopItem) *ShopPurchaseInpl <span class="cov8" title="1">{
        uc := &amp;ShopPurchaseInpl{
                logger:           logger,
                config:           config,
                txManager:        txManager,
                repo:             repo,
                usecaseAccount:   usecaseAccount,
                usecaseOperation: usecaseOperation,
                usecaseShopItem:  usecaseShopItem,
        }
        return uc
}</span>

func (uc *ShopPurchaseInpl) MakePurchase(ctx context.Context, itemName string, accountID uuid.UUID, quantity int64, identityKey *uuid.UUID) (*domain.ShopPurchase, error) <span class="cov8" title="1">{
        var err error
        var shopPurchase *domain.ShopPurchase

        err = uc.txManager.Do(ctx, func(ctx context.Context) error </span><span class="cov8" title="1">{
                if identityKey != nil </span><span class="cov8" title="1">{
                        isIdentityExists, err := uc.repo.FindIdentity(ctx, *identityKey)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if isIdentityExists </span><span class="cov8" title="1">{
                                return e.ErrConflict
                        }</span>
                }

                <span class="cov8" title="1">shopItem, err := uc.usecaseShopItem.GetItemByName(ctx, itemName)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">shopPurchase = domain.NewShopPurchase(shopItem.ID, accountID, quantity, identityKey)

                operation := domain.NewOperation(domain.OperationTypeDecrease, accountID, shopItem.Price*quantity, domain.OperationSourceTypeShopPurchase, &amp;shopPurchase.ID)

                _, err = uc.usecaseOperation.SaveOperation(ctx, operation)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">err = uc.repo.Create(ctx, shopPurchase)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if !e.IsAppError(err) </span><span class="cov8" title="1">{
                        return nil, e.NewErrorFrom(e.ErrInternal).Wrap(err)
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">return shopPurchase, nil</span>
}

func (uc *ShopPurchaseInpl) GetInventory(ctx context.Context, accountID uuid.UUID) ([]ShopPurchaseGetInventoryItem, error) <span class="cov8" title="1">{
        inventory, err := uc.repo.AggrInventoryByAccountID(ctx, accountID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">shopItemsIDs := make([]uuid.UUID, 0, len(inventory))
        for _, item := range inventory </span><span class="cov8" title="1">{
                shopItemsIDs = append(shopItemsIDs, item.ShopItemID)
        }</span>

        <span class="cov8" title="1">shopItems, err := uc.usecaseShopItem.GetItemsByIDs(ctx, shopItemsIDs)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := make([]ShopPurchaseGetInventoryItem, 0, len(inventory))

        for _, item := range inventory </span><span class="cov8" title="1">{
                resultItem := ShopPurchaseGetInventoryItem{
                        Quantity: item.Quantity,
                }
                if shopItem, ok := shopItems[item.ShopItemID]; ok </span><span class="cov8" title="1">{
                        resultItem.ShopItem = &amp;shopItem
                }</span>

                <span class="cov8" title="1">result = append(result, resultItem)</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package dbhelper

import (
        "fmt"
        "reflect"
        "sync"
)

type ConverterFunc func(src interface{}) (interface{}, error)

var convertersMu sync.RWMutex

var converters = make(map[string]ConverterFunc)

func converterKey(srcType, dstType reflect.Type) string <span class="cov8" title="1">{
        return srcType.String() + "-&gt;" + dstType.String()
}</span>

func RegisterBidirectionalConverter(dbType, domainType reflect.Type,
        dbToDomain ConverterFunc, domainToDB ConverterFunc,
) <span class="cov8" title="1">{
        convertersMu.Lock()
        defer convertersMu.Unlock()
        converters[converterKey(dbType, domainType)] = dbToDomain
        converters[converterKey(domainType, dbType)] = domainToDB
}</span>

func getConverter(srcType, dstType reflect.Type) (ConverterFunc, bool) <span class="cov8" title="1">{
        convertersMu.RLock()
        defer convertersMu.RUnlock()
        conv, ok := converters[converterKey(srcType, dstType)]
        return conv, ok
}</span>

func safeConvert(conv ConverterFunc, src interface{}) (result interface{}, err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov8" title="1">{
                        err = fmt.Errorf("panic in converter: %v", r)
                }</span>
        }()
        <span class="cov8" title="1">result, err = conv(src)
        return</span>
}

func ConvertDBToDomain(dbRecord, domainModel interface{}) error <span class="cov8" title="1">{
        dbVal := reflect.ValueOf(dbRecord)
        if dbVal.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                dbVal = dbVal.Elem()
        }</span>
        <span class="cov8" title="1">if dbVal.Kind() != reflect.Struct </span><span class="cov8" title="1">{
                return fmt.Errorf("dbRecord must be a struct or pointer to a struct")
        }</span>

        <span class="cov8" title="1">dVal := reflect.ValueOf(domainModel)
        if dVal.Kind() != reflect.Ptr || dVal.Elem().Kind() != reflect.Struct </span><span class="cov8" title="1">{
                return fmt.Errorf("domainModel must be a pointer to a struct")
        }</span>
        <span class="cov8" title="1">dVal = dVal.Elem()
        dType := dVal.Type()

        dbType := dbVal.Type()
        for i := 0; i &lt; dbType.NumField(); i++ </span><span class="cov8" title="1">{
                dbField := dbType.Field(i)
                dbFieldValue := dbVal.Field(i)
                if !dbFieldValue.IsValid() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">fieldName := dbField.Name

                dField, found := dType.FieldByName(fieldName)
                if !found </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">dFieldVal := dVal.FieldByName(dField.Name)
                if !dFieldVal.CanSet() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">srcType := dbFieldValue.Type()
                dstType := dFieldVal.Type()

                if conv, ok := getConverter(srcType, dstType); ok </span><span class="cov8" title="1">{
                        converted, err := safeConvert(conv, dbFieldValue.Interface())
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("converter error for field %s: %v", dbField.Name, err)
                        }</span>
                        <span class="cov8" title="1">convVal := reflect.ValueOf(converted)
                        if !convVal.Type().AssignableTo(dstType) </span><span class="cov0" title="0">{
                                return fmt.Errorf("converted value for field %s is not assignable to type %s", dbField.Name, dstType)
                        }</span>
                        <span class="cov8" title="1">dFieldVal.Set(convVal)
                        continue</span>
                }

                <span class="cov8" title="1">if srcType.AssignableTo(dstType) </span><span class="cov8" title="1">{
                        dFieldVal.Set(dbFieldValue)
                        continue</span>
                }

                <span class="cov8" title="1">if srcType.ConvertibleTo(dstType) </span><span class="cov0" title="0">{
                        dFieldVal.Set(dbFieldValue.Convert(dstType))
                        continue</span>
                }

                <span class="cov8" title="1">return fmt.Errorf("no converter registered for field %s: %s -&gt; %s", dbField.Name, srcType, dstType)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func StructToDBMap(src, dbSchema interface{}) (map[string]interface{}, error) <span class="cov8" title="1">{
        result := make(map[string]interface{})

        schemaVal := reflect.ValueOf(dbSchema)
        if schemaVal.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                schemaVal = schemaVal.Elem()
        }</span>
        <span class="cov8" title="1">if schemaVal.Kind() != reflect.Struct </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("dbSchema must be a struct or pointer to a struct")
        }</span>
        <span class="cov8" title="1">schemaType := schemaVal.Type()

        srcVal := reflect.ValueOf(src)
        if srcVal.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                srcVal = srcVal.Elem()
        }</span>
        <span class="cov8" title="1">if srcVal.Kind() != reflect.Struct </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("src must be a struct or pointer to a struct")
        }</span>
        <span class="cov8" title="1">srcType := srcVal.Type()

        for i := 0; i &lt; schemaType.NumField(); i++ </span><span class="cov8" title="1">{
                schemaField := schemaType.Field(i)
                key := schemaField.Tag.Get("db")
                if key == "" </span><span class="cov0" title="0">{
                        key = schemaField.Name
                }</span>

                <span class="cov8" title="1">srcField, found := srcType.FieldByName(schemaField.Name)
                if !found </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">srcFieldVal := srcVal.FieldByName(srcField.Name)
                expectedType := schemaField.Type

                srcTypeVal := srcFieldVal.Type()

                if conv, ok := getConverter(srcTypeVal, expectedType); ok </span><span class="cov8" title="1">{
                        converted, err := safeConvert(conv, srcFieldVal.Interface())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("cant convert field %s: %v", schemaField.Name, err)
                        }</span>
                        <span class="cov8" title="1">convVal := reflect.ValueOf(converted)
                        if !convVal.Type().AssignableTo(expectedType) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">result[key] = converted
                        continue</span>
                }

                <span class="cov8" title="1">if srcTypeVal.AssignableTo(expectedType) </span><span class="cov8" title="1">{
                        result[key] = srcFieldVal.Interface()
                        continue</span>
                }

                <span class="cov8" title="1">if srcTypeVal.ConvertibleTo(expectedType) </span><span class="cov0" title="0">{
                        convVal := srcFieldVal.Convert(expectedType)
                        result[key] = convVal.Interface()
                        continue</span>
                }
        }
        <span class="cov8" title="1">return result, nil</span>
}

func ExtractDBFields(dbModel interface{}) []string <span class="cov8" title="1">{
        val := reflect.ValueOf(dbModel)
        if val.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                val = val.Elem()
        }</span>
        <span class="cov8" title="1">if val.Kind() != reflect.Struct </span><span class="cov8" title="1">{
                return []string{}
        }</span>
        <span class="cov8" title="1">typ := val.Type()
        var fields []string
        for i := 0; i &lt; typ.NumField(); i++ </span><span class="cov8" title="1">{
                field := typ.Field(i)
                dbTag := field.Tag.Get("db")
                if dbTag == "" </span><span class="cov0" title="0">{
                        dbTag = field.Name
                }</span>
                <span class="cov8" title="1">fields = append(fields, dbTag)</span>
        }
        <span class="cov8" title="1">return fields</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package e

import "fmt"

type LogicError struct {
        onlyRead bool
        code     int
        message  string
        details  []string
        wrapErr  []error
        data     any
}

func (e *LogicError) Error() string <span class="cov8" title="1">{
        if len(e.details) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s - details: %v", e.message, e.details)
        }</span>
        <span class="cov8" title="1">return e.message</span>
}

func IsAppError(err error) bool <span class="cov8" title="1">{
        _, ok := err.(*LogicError)
        return ok
}</span>

func NewError(code int, message string, details []string) *LogicError <span class="cov8" title="1">{
        return &amp;LogicError{
                code:    code,
                message: message,
                details: details,
        }
}</span>

func NewErrorFrom(parentErr *LogicError) *LogicError <span class="cov8" title="1">{
        e := &amp;LogicError{
                code:    parentErr.code,
                message: parentErr.message,
                details: parentErr.details,
        }
        return e.Wrap(parentErr)
}</span>

func (e *LogicError) Wrap(err error) *LogicError <span class="cov8" title="1">{
        if e.onlyRead </span><span class="cov8" title="1">{
                return e
        }</span>

        <span class="cov8" title="1">e.wrapErr = append(e.wrapErr, err)
        return e</span>
}

func (e *LogicError) Unwrap() []error <span class="cov8" title="1">{
        return e.wrapErr
}</span>

func (e *LogicError) Is(err error) bool <span class="cov8" title="1">{
        if e == err </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">for _, wErr := range e.wrapErr </span><span class="cov8" title="1">{
                if wErr == err </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (e *LogicError) Lock() *LogicError <span class="cov8" title="1">{
        e.onlyRead = true
        return e
}</span>

func (e *LogicError) Code() int <span class="cov8" title="1">{
        return e.code
}</span>

func (e *LogicError) Message() string <span class="cov8" title="1">{
        return e.message
}</span>

func (e *LogicError) Details() []string <span class="cov8" title="1">{
        return e.details
}</span>

func (e *LogicError) SetMessage(message string) *LogicError <span class="cov8" title="1">{
        if e.onlyRead </span><span class="cov8" title="1">{
                return e
        }</span>
        <span class="cov8" title="1">e.message = message
        return e</span>
}

func (e *LogicError) AddDetails(details []string) *LogicError <span class="cov8" title="1">{
        if e.onlyRead </span><span class="cov8" title="1">{
                return e
        }</span>
        <span class="cov8" title="1">if e.details == nil </span><span class="cov0" title="0">{
                return e
        }</span>
        <span class="cov8" title="1">if e.details == nil </span><span class="cov0" title="0">{
                e.details = make([]string, len(details))
        }</span>
        <span class="cov8" title="1">e.details = append(e.details, details...)
        return e</span>
}

func (e *LogicError) Data() any <span class="cov8" title="1">{
        return e.data
}</span>

func (e *LogicError) SetData(data any) *LogicError <span class="cov8" title="1">{
        if e.onlyRead </span><span class="cov8" title="1">{
                return e
        }</span>

        <span class="cov8" title="1">e.data = data
        return e</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package e

import (
        "errors"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

func ErrCheckIsTxСoncurrentExec(err error) bool <span class="cov8" title="1">{
        var pgErr *pgconn.PgError
        if errors.As(err, &amp;pgErr) &amp;&amp; (pgErr.Code == "40001" || pgErr.Code == "25P02") </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return errors.Is(err, ErrTxСoncurrentExec)</span>
}

func ErrConvertPgxToLogic(err error) (bool, error) <span class="cov8" title="1">{
        if errors.Is(err, pgx.ErrNoRows) </span><span class="cov8" title="1">{
                return true, NewErrorFrom(ErrStoreNoRows).Wrap(err)
        }</span>
        <span class="cov8" title="1">var pgErr *pgconn.PgError
        if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                switch </span>{
                case pgErr.Code == "40001":<span class="cov8" title="1">
                        return true, NewErrorFrom(ErrTxСoncurrentExec).Wrap(err)</span>
                case pgErr.Code == "25P02":<span class="cov8" title="1">
                        return true, NewErrorFrom(ErrTxСoncurrentExec).Wrap(err)</span>
                case pgErr.Code == "23505":<span class="cov8" title="1">
                        return true, NewErrorFrom(ErrStoreUniqueViolation).Wrap(err).SetData(pgErr.ColumnName)</span>
                case pgErr.Code == "23503":<span class="cov8" title="1">
                        return true, NewErrorFrom(ErrStoreForeignKeyViolation).Wrap(err).SetData(pgErr.ColumnName)</span>
                case pgErr.Code == "23502":<span class="cov8" title="1">
                        return true, NewErrorFrom(ErrStoreNotNullViolation).Wrap(err).SetData(pgErr.ColumnName)</span>
                case pgErr.Code == "23514":<span class="cov8" title="1">
                        return true, NewErrorFrom(ErrStoreCheckViolation).Wrap(err).SetData(pgErr.ConstraintName)</span>
                case pgErr.Code == "23001":<span class="cov8" title="1">
                        return true, NewErrorFrom(ErrStoreRestrictViolation).Wrap(err).SetData(pgErr.ConstraintName)</span>
                case pgErr.Code == "23000":<span class="cov8" title="1">
                        return true, NewErrorFrom(ErrStoreIntegrityViolation).Wrap(err).SetData(pgErr.ConstraintName)</span>
                default:<span class="cov8" title="1">
                        return false, NewErrorFrom(ErrInternal).Wrap(err)</span>
                }
        }
        <span class="cov8" title="1">return false, err</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Code generated by mockery v2.52.2. DO NOT EDIT.

package mocks

import (
        context "context"

        domain "github.com/m11ano/avito-shop/internal/domain"
        mock "github.com/stretchr/testify/mock"

        uuid "github.com/google/uuid"
)

// Account is an autogenerated mock type for the Account type
type Account struct {
        mock.Mock
}

// Create provides a mock function with given fields: ctx, account
func (_m *Account) Create(ctx context.Context, account *domain.Account) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, account)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Create")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *domain.Account) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, account)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// GetItemByUsername provides a mock function with given fields: ctx, username
func (_m *Account) GetItemByUsername(ctx context.Context, username string) (*domain.Account, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, username)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetItemByUsername")</span>
        }

        <span class="cov8" title="1">var r0 *domain.Account
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (*domain.Account, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, username)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string) *domain.Account); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, username)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*domain.Account)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, username)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// GetItemsByIDs provides a mock function with given fields: ctx, ids
func (_m *Account) GetItemsByIDs(ctx context.Context, ids []uuid.UUID) (map[uuid.UUID]domain.Account, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, ids)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetItemsByIDs")</span>
        }

        <span class="cov8" title="1">var r0 map[uuid.UUID]domain.Account
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, []uuid.UUID) (map[uuid.UUID]domain.Account, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, ids)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, []uuid.UUID) map[uuid.UUID]domain.Account); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, ids)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(map[uuid.UUID]domain.Account)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, []uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, ids)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// NewAccount creates a new instance of Account. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAccount(t interface {
        mock.TestingT
        Cleanup(func())
}) *Account <span class="cov0" title="0">{
        mock := &amp;Account{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Code generated by mockery v2.52.2. DO NOT EDIT.

package mocks

import (
        context "context"

        domain "github.com/m11ano/avito-shop/internal/domain"
        mock "github.com/stretchr/testify/mock"

        uuid "github.com/google/uuid"
)

// AccountRepository is an autogenerated mock type for the AccountRepository type
type AccountRepository struct {
        mock.Mock
}

// Create provides a mock function with given fields: ctx, account
func (_m *AccountRepository) Create(ctx context.Context, account *domain.Account) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, account)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Create")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *domain.Account) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, account)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// FindItemByUsername provides a mock function with given fields: ctx, username
func (_m *AccountRepository) FindItemByUsername(ctx context.Context, username string) (*domain.Account, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, username)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for FindItemByUsername")</span>
        }

        <span class="cov8" title="1">var r0 *domain.Account
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (*domain.Account, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, username)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string) *domain.Account); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, username)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*domain.Account)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, username)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// FindItemsByIDs provides a mock function with given fields: ctx, ids
func (_m *AccountRepository) FindItemsByIDs(ctx context.Context, ids []uuid.UUID) (map[uuid.UUID]domain.Account, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, ids)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for FindItemsByIDs")</span>
        }

        <span class="cov8" title="1">var r0 map[uuid.UUID]domain.Account
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, []uuid.UUID) (map[uuid.UUID]domain.Account, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, ids)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, []uuid.UUID) map[uuid.UUID]domain.Account); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, ids)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(map[uuid.UUID]domain.Account)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, []uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, ids)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// NewAccountRepository creates a new instance of AccountRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAccountRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *AccountRepository <span class="cov0" title="0">{
        mock := &amp;AccountRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Code generated by mockery v2.52.2. DO NOT EDIT.

package mocks

import (
        context "context"

        mock "github.com/stretchr/testify/mock"

        uuid "github.com/google/uuid"
)

// Auth is an autogenerated mock type for the Auth type
type Auth struct {
        mock.Mock
}

// AuthByJWTToken provides a mock function with given fields: ctx, jwtToken
func (_m *Auth) AuthByJWTToken(ctx context.Context, jwtToken string) (*uuid.UUID, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, jwtToken)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for AuthByJWTToken")</span>
        }

        <span class="cov0" title="0">var r0 *uuid.UUID
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (*uuid.UUID, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, jwtToken)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string) *uuid.UUID); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, jwtToken)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*uuid.UUID)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, jwtToken)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// SignInOrSignUp provides a mock function with given fields: ctx, username, password
func (_m *Auth) SignInOrSignUp(ctx context.Context, username string, password string) (string, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, username, password)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for SignInOrSignUp")</span>
        }

        <span class="cov0" title="0">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, string) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, username, password)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, string) string); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, username, password)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, username, password)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NewAuth creates a new instance of Auth. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAuth(t interface {
        mock.TestingT
        Cleanup(func())
}) *Auth <span class="cov0" title="0">{
        mock := &amp;Auth{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Code generated by mockery v2.52.2. DO NOT EDIT.

package mocks

import (
        context "context"

        domain "github.com/m11ano/avito-shop/internal/domain"
        mock "github.com/stretchr/testify/mock"

        usecase "github.com/m11ano/avito-shop/internal/usecase"

        uuid "github.com/google/uuid"
)

// CoinTransfer is an autogenerated mock type for the CoinTransfer type
type CoinTransfer struct {
        mock.Mock
}

// GetAggrCoinHistory provides a mock function with given fields: ctx, accountID, transferType
func (_m *CoinTransfer) GetAggrCoinHistory(ctx context.Context, accountID uuid.UUID, transferType domain.CoinTransferType) ([]usecase.CoinTransferGetAggrHistoryItem, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, accountID, transferType)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetAggrCoinHistory")</span>
        }

        <span class="cov0" title="0">var r0 []usecase.CoinTransferGetAggrHistoryItem
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, domain.CoinTransferType) ([]usecase.CoinTransferGetAggrHistoryItem, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, accountID, transferType)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, domain.CoinTransferType) []usecase.CoinTransferGetAggrHistoryItem); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, accountID, transferType)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]usecase.CoinTransferGetAggrHistoryItem)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, domain.CoinTransferType) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, accountID, transferType)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MakeTransferByUsername provides a mock function with given fields: ctx, targetAccountUsername, ownerAccountID, amount, identityKey
func (_m *CoinTransfer) MakeTransferByUsername(ctx context.Context, targetAccountUsername string, ownerAccountID uuid.UUID, amount int64, identityKey *uuid.UUID) (*domain.CoinTransfer, *domain.CoinTransfer, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, targetAccountUsername, ownerAccountID, amount, identityKey)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for MakeTransferByUsername")</span>
        }

        <span class="cov0" title="0">var r0 *domain.CoinTransfer
        var r1 *domain.CoinTransfer
        var r2 error
        if rf, ok := ret.Get(0).(func(context.Context, string, uuid.UUID, int64, *uuid.UUID) (*domain.CoinTransfer, *domain.CoinTransfer, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, targetAccountUsername, ownerAccountID, amount, identityKey)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, uuid.UUID, int64, *uuid.UUID) *domain.CoinTransfer); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, targetAccountUsername, ownerAccountID, amount, identityKey)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*domain.CoinTransfer)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, uuid.UUID, int64, *uuid.UUID) *domain.CoinTransfer); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, targetAccountUsername, ownerAccountID, amount, identityKey)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(1) != nil </span><span class="cov0" title="0">{
                        r1 = ret.Get(1).(*domain.CoinTransfer)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(2).(func(context.Context, string, uuid.UUID, int64, *uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r2 = rf(ctx, targetAccountUsername, ownerAccountID, amount, identityKey)
        }</span> else<span class="cov0" title="0"> {
                r2 = ret.Error(2)
        }</span>

        <span class="cov0" title="0">return r0, r1, r2</span>
}

// NewCoinTransfer creates a new instance of CoinTransfer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCoinTransfer(t interface {
        mock.TestingT
        Cleanup(func())
}) *CoinTransfer <span class="cov0" title="0">{
        mock := &amp;CoinTransfer{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">// Code generated by mockery v2.52.2. DO NOT EDIT.

package mocks

import (
        context "context"

        domain "github.com/m11ano/avito-shop/internal/domain"
        mock "github.com/stretchr/testify/mock"

        usecase "github.com/m11ano/avito-shop/internal/usecase"

        uuid "github.com/google/uuid"
)

// CoinTransferRepository is an autogenerated mock type for the CoinTransferRepository type
type CoinTransferRepository struct {
        mock.Mock
}

// Create provides a mock function with given fields: ctx, coinTransfer
func (_m *CoinTransferRepository) Create(ctx context.Context, coinTransfer *domain.CoinTransfer) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, coinTransfer)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Create")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *domain.CoinTransfer) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, coinTransfer)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// FindIdentity provides a mock function with given fields: ctx, identityKey
func (_m *CoinTransferRepository) FindIdentity(ctx context.Context, identityKey uuid.UUID) (bool, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, identityKey)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for FindIdentity")</span>
        }

        <span class="cov8" title="1">var r0 bool
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (bool, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, identityKey)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, identityKey)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, identityKey)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// GetAggrCoinHistoryByAccountID provides a mock function with given fields: ctx, accountID, transferType
func (_m *CoinTransferRepository) GetAggrCoinHistoryByAccountID(ctx context.Context, accountID uuid.UUID, transferType domain.CoinTransferType) ([]usecase.CoinTransferRepositoryAggrHistoryItem, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, accountID, transferType)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetAggrCoinHistoryByAccountID")</span>
        }

        <span class="cov8" title="1">var r0 []usecase.CoinTransferRepositoryAggrHistoryItem
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, domain.CoinTransferType) ([]usecase.CoinTransferRepositoryAggrHistoryItem, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, accountID, transferType)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, domain.CoinTransferType) []usecase.CoinTransferRepositoryAggrHistoryItem); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, accountID, transferType)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).([]usecase.CoinTransferRepositoryAggrHistoryItem)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, domain.CoinTransferType) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, accountID, transferType)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// NewCoinTransferRepository creates a new instance of CoinTransferRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCoinTransferRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *CoinTransferRepository <span class="cov0" title="0">{
        mock := &amp;CoinTransferRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">// Code generated by mockery v2.52.2. DO NOT EDIT.

package mocks

import (
        context "context"

        domain "github.com/m11ano/avito-shop/internal/domain"
        mock "github.com/stretchr/testify/mock"

        uuid "github.com/google/uuid"
)

// Operation is an autogenerated mock type for the Operation type
type Operation struct {
        mock.Mock
}

// GetBalanceByAccountID provides a mock function with given fields: ctx, accountID
func (_m *Operation) GetBalanceByAccountID(ctx context.Context, accountID uuid.UUID) (int64, bool, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, accountID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetBalanceByAccountID")</span>
        }

        <span class="cov0" title="0">var r0 int64
        var r1 bool
        var r2 error
        if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (int64, bool, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, accountID)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) int64); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, accountID)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(int64)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) bool); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, accountID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Get(1).(bool)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(2).(func(context.Context, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r2 = rf(ctx, accountID)
        }</span> else<span class="cov0" title="0"> {
                r2 = ret.Error(2)
        }</span>

        <span class="cov0" title="0">return r0, r1, r2</span>
}

// SaveOperation provides a mock function with given fields: ctx, operation
func (_m *Operation) SaveOperation(ctx context.Context, operation *domain.Operation) (int64, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, operation)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for SaveOperation")</span>
        }

        <span class="cov8" title="1">var r0 int64
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *domain.Operation) (int64, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, operation)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, *domain.Operation) int64); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, operation)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(int64)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, *domain.Operation) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, operation)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// NewOperation creates a new instance of Operation. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewOperation(t interface {
        mock.TestingT
        Cleanup(func())
}) *Operation <span class="cov0" title="0">{
        mock := &amp;Operation{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// Code generated by mockery v2.52.2. DO NOT EDIT.

package mocks

import (
        context "context"

        domain "github.com/m11ano/avito-shop/internal/domain"
        mock "github.com/stretchr/testify/mock"

        uuid "github.com/google/uuid"
)

// OperationRepository is an autogenerated mock type for the OperationRepository type
type OperationRepository struct {
        mock.Mock
}

// Create provides a mock function with given fields: ctx, operation
func (_m *OperationRepository) Create(ctx context.Context, operation *domain.Operation) (int64, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, operation)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Create")</span>
        }

        <span class="cov8" title="1">var r0 int64
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *domain.Operation) (int64, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, operation)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, *domain.Operation) int64); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, operation)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(int64)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, *domain.Operation) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, operation)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// GetBalanceByAccountID provides a mock function with given fields: ctx, accountID
func (_m *OperationRepository) GetBalanceByAccountID(ctx context.Context, accountID uuid.UUID) (int64, bool, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, accountID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetBalanceByAccountID")</span>
        }

        <span class="cov8" title="1">var r0 int64
        var r1 bool
        var r2 error
        if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (int64, bool, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, accountID)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) int64); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, accountID)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(int64)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) bool); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, accountID)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Get(1).(bool)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(2).(func(context.Context, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r2 = rf(ctx, accountID)
        }</span> else<span class="cov8" title="1"> {
                r2 = ret.Error(2)
        }</span>

        <span class="cov8" title="1">return r0, r1, r2</span>
}

// NewOperationRepository creates a new instance of OperationRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewOperationRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *OperationRepository <span class="cov0" title="0">{
        mock := &amp;OperationRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">// Code generated by mockery v2.52.2. DO NOT EDIT.

package mocks

import (
        context "context"

        pgconn "github.com/jackc/pgx/v5/pgconn"
        mock "github.com/stretchr/testify/mock"

        pgx "github.com/jackc/pgx/v5"

        pgxpool "github.com/jackc/pgx/v5/pgxpool"
)

// PgxPool is an autogenerated mock type for the PgxPool type
type PgxPool struct {
        mock.Mock
}

// Acquire provides a mock function with given fields: ctx
func (_m *PgxPool) Acquire(ctx context.Context) (*pgxpool.Conn, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Acquire")</span>
        }

        <span class="cov0" title="0">var r0 *pgxpool.Conn
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context) (*pgxpool.Conn, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context) *pgxpool.Conn); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*pgxpool.Conn)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// AcquireAllIdle provides a mock function with given fields: ctx
func (_m *PgxPool) AcquireAllIdle(ctx context.Context) []*pgxpool.Conn <span class="cov0" title="0">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for AcquireAllIdle")</span>
        }

        <span class="cov0" title="0">var r0 []*pgxpool.Conn
        if rf, ok := ret.Get(0).(func(context.Context) []*pgxpool.Conn); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]*pgxpool.Conn)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// AcquireFunc provides a mock function with given fields: ctx, f
func (_m *PgxPool) AcquireFunc(ctx context.Context, f func(*pgxpool.Conn) error) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, f)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for AcquireFunc")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, func(*pgxpool.Conn) error) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, f)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// Begin provides a mock function with given fields: ctx
func (_m *PgxPool) Begin(ctx context.Context) (pgx.Tx, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Begin")</span>
        }

        <span class="cov0" title="0">var r0 pgx.Tx
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context) (pgx.Tx, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context) pgx.Tx); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(pgx.Tx)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// BeginTx provides a mock function with given fields: ctx, txOptions
func (_m *PgxPool) BeginTx(ctx context.Context, txOptions pgx.TxOptions) (pgx.Tx, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, txOptions)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for BeginTx")</span>
        }

        <span class="cov8" title="1">var r0 pgx.Tx
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, pgx.TxOptions) (pgx.Tx, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, txOptions)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, pgx.TxOptions) pgx.Tx); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, txOptions)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(pgx.Tx)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, pgx.TxOptions) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, txOptions)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// Close provides a mock function with no fields
func (_m *PgxPool) Close() <span class="cov0" title="0">{
        _m.Called()
}</span>

// Config provides a mock function with no fields
func (_m *PgxPool) Config() *pgxpool.Config <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Config")</span>
        }

        <span class="cov0" title="0">var r0 *pgxpool.Config
        if rf, ok := ret.Get(0).(func() *pgxpool.Config); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*pgxpool.Config)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// CopyFrom provides a mock function with given fields: ctx, tableName, columnNames, rowSrc
func (_m *PgxPool) CopyFrom(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (int64, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, tableName, columnNames, rowSrc)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CopyFrom")</span>
        }

        <span class="cov0" title="0">var r0 int64
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, pgx.Identifier, []string, pgx.CopyFromSource) (int64, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tableName, columnNames, rowSrc)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, pgx.Identifier, []string, pgx.CopyFromSource) int64); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tableName, columnNames, rowSrc)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(int64)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, pgx.Identifier, []string, pgx.CopyFromSource) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tableName, columnNames, rowSrc)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// Exec provides a mock function with given fields: ctx, sql, arguments
func (_m *PgxPool) Exec(ctx context.Context, sql string, arguments ...interface{}) (pgconn.CommandTag, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, ctx, sql)
        _ca = append(_ca, arguments...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Exec")</span>
        }

        <span class="cov0" title="0">var r0 pgconn.CommandTag
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) (pgconn.CommandTag, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, sql, arguments...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) pgconn.CommandTag); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, sql, arguments...)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(pgconn.CommandTag)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, sql, arguments...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// Ping provides a mock function with given fields: ctx
func (_m *PgxPool) Ping(ctx context.Context) error <span class="cov0" title="0">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Ping")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// Query provides a mock function with given fields: ctx, sql, args
func (_m *PgxPool) Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, ctx, sql)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Query")</span>
        }

        <span class="cov0" title="0">var r0 pgx.Rows
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) (pgx.Rows, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, sql, args...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) pgx.Rows); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, sql, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(pgx.Rows)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, sql, args...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// QueryRow provides a mock function with given fields: ctx, sql, args
func (_m *PgxPool) QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, ctx, sql)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for QueryRow")</span>
        }

        <span class="cov0" title="0">var r0 pgx.Row
        if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) pgx.Row); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, sql, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(pgx.Row)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// Reset provides a mock function with no fields
func (_m *PgxPool) Reset() <span class="cov0" title="0">{
        _m.Called()
}</span>

// SendBatch provides a mock function with given fields: ctx, b
func (_m *PgxPool) SendBatch(ctx context.Context, b *pgx.Batch) pgx.BatchResults <span class="cov0" title="0">{
        ret := _m.Called(ctx, b)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for SendBatch")</span>
        }

        <span class="cov0" title="0">var r0 pgx.BatchResults
        if rf, ok := ret.Get(0).(func(context.Context, *pgx.Batch) pgx.BatchResults); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, b)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(pgx.BatchResults)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// Stat provides a mock function with no fields
func (_m *PgxPool) Stat() *pgxpool.Stat <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Stat")</span>
        }

        <span class="cov0" title="0">var r0 *pgxpool.Stat
        if rf, ok := ret.Get(0).(func() *pgxpool.Stat); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*pgxpool.Stat)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// NewPgxPool creates a new instance of PgxPool. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPgxPool(t interface {
        mock.TestingT
        Cleanup(func())
}) *PgxPool <span class="cov0" title="0">{
        mock := &amp;PgxPool{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package mocks

import (
        mock "github.com/stretchr/testify/mock"
)

func NewPgxPoolMockForTxManager() *PgxPool <span class="cov8" title="1">{
        mockPool := new(PgxPool)
        mockTx := new(PoolTxInterface)

        // Настраиваем пул: при вызове BeginTx(...) он вернёт mockTx
        mockPool.On("BeginTx", mock.Anything, mock.AnythingOfType("pgx.TxOptions")).Return(mockTx, nil)

        // Настраиваем транзакцию: Commit и Rollback возвращают nil (успех)
        mockTx.On("Commit", mock.Anything).Return(nil)
        mockTx.On("Rollback", mock.Anything).Return(nil)

        return mockPool
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">// Code generated by mockery v2.52.2. DO NOT EDIT.

package mocks

import (
        context "context"

        mock "github.com/stretchr/testify/mock"

        pgconn "github.com/jackc/pgx/v5/pgconn"

        pgx "github.com/jackc/pgx/v5"
)

// PoolTxInterface is an autogenerated mock type for the PoolTxInterface type
type PoolTxInterface struct {
        mock.Mock
}

// Begin provides a mock function with given fields: ctx
func (_m *PoolTxInterface) Begin(ctx context.Context) (pgx.Tx, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Begin")</span>
        }

        <span class="cov0" title="0">var r0 pgx.Tx
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context) (pgx.Tx, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context) pgx.Tx); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(pgx.Tx)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// Commit provides a mock function with given fields: ctx
func (_m *PoolTxInterface) Commit(ctx context.Context) error <span class="cov8" title="1">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Commit")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// Conn provides a mock function with no fields
func (_m *PoolTxInterface) Conn() *pgx.Conn <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Conn")</span>
        }

        <span class="cov0" title="0">var r0 *pgx.Conn
        if rf, ok := ret.Get(0).(func() *pgx.Conn); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*pgx.Conn)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// CopyFrom provides a mock function with given fields: ctx, tableName, columnNames, rowSrc
func (_m *PoolTxInterface) CopyFrom(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (int64, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, tableName, columnNames, rowSrc)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CopyFrom")</span>
        }

        <span class="cov0" title="0">var r0 int64
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, pgx.Identifier, []string, pgx.CopyFromSource) (int64, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tableName, columnNames, rowSrc)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, pgx.Identifier, []string, pgx.CopyFromSource) int64); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tableName, columnNames, rowSrc)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(int64)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, pgx.Identifier, []string, pgx.CopyFromSource) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tableName, columnNames, rowSrc)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// Exec provides a mock function with given fields: ctx, sql, arguments
func (_m *PoolTxInterface) Exec(ctx context.Context, sql string, arguments ...interface{}) (pgconn.CommandTag, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, ctx, sql)
        _ca = append(_ca, arguments...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Exec")</span>
        }

        <span class="cov0" title="0">var r0 pgconn.CommandTag
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) (pgconn.CommandTag, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, sql, arguments...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) pgconn.CommandTag); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, sql, arguments...)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(pgconn.CommandTag)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, sql, arguments...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// LargeObjects provides a mock function with no fields
func (_m *PoolTxInterface) LargeObjects() pgx.LargeObjects <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for LargeObjects")</span>
        }

        <span class="cov0" title="0">var r0 pgx.LargeObjects
        if rf, ok := ret.Get(0).(func() pgx.LargeObjects); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(pgx.LargeObjects)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// Prepare provides a mock function with given fields: ctx, name, sql
func (_m *PoolTxInterface) Prepare(ctx context.Context, name string, sql string) (*pgconn.StatementDescription, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, name, sql)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Prepare")</span>
        }

        <span class="cov0" title="0">var r0 *pgconn.StatementDescription
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, string) (*pgconn.StatementDescription, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, name, sql)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, string) *pgconn.StatementDescription); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, name, sql)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*pgconn.StatementDescription)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, name, sql)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// Query provides a mock function with given fields: ctx, sql, args
func (_m *PoolTxInterface) Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, ctx, sql)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Query")</span>
        }

        <span class="cov0" title="0">var r0 pgx.Rows
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) (pgx.Rows, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, sql, args...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) pgx.Rows); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, sql, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(pgx.Rows)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, sql, args...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// QueryRow provides a mock function with given fields: ctx, sql, args
func (_m *PoolTxInterface) QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, ctx, sql)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for QueryRow")</span>
        }

        <span class="cov0" title="0">var r0 pgx.Row
        if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) pgx.Row); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, sql, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(pgx.Row)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// Rollback provides a mock function with given fields: ctx
func (_m *PoolTxInterface) Rollback(ctx context.Context) error <span class="cov8" title="1">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Rollback")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// SendBatch provides a mock function with given fields: ctx, b
func (_m *PoolTxInterface) SendBatch(ctx context.Context, b *pgx.Batch) pgx.BatchResults <span class="cov0" title="0">{
        ret := _m.Called(ctx, b)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for SendBatch")</span>
        }

        <span class="cov0" title="0">var r0 pgx.BatchResults
        if rf, ok := ret.Get(0).(func(context.Context, *pgx.Batch) pgx.BatchResults); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, b)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(pgx.BatchResults)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// NewPoolTxInterface creates a new instance of PoolTxInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPoolTxInterface(t interface {
        mock.TestingT
        Cleanup(func())
}) *PoolTxInterface <span class="cov0" title="0">{
        mock := &amp;PoolTxInterface{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">// Code generated by mockery v2.52.2. DO NOT EDIT.

package mocks

import (
        context "context"

        domain "github.com/m11ano/avito-shop/internal/domain"
        mock "github.com/stretchr/testify/mock"

        uuid "github.com/google/uuid"
)

// ShopItem is an autogenerated mock type for the ShopItem type
type ShopItem struct {
        mock.Mock
}

// GetItemByID provides a mock function with given fields: ctx, id
func (_m *ShopItem) GetItemByID(ctx context.Context, id uuid.UUID) (*domain.ShopItem, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetItemByID")</span>
        }

        <span class="cov0" title="0">var r0 *domain.ShopItem
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*domain.ShopItem, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, id)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *domain.ShopItem); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*domain.ShopItem)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetItemByName provides a mock function with given fields: ctx, name
func (_m *ShopItem) GetItemByName(ctx context.Context, name string) (*domain.ShopItem, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetItemByName")</span>
        }

        <span class="cov8" title="1">var r0 *domain.ShopItem
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (*domain.ShopItem, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, name)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string) *domain.ShopItem); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, name)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*domain.ShopItem)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, name)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// GetItemsByIDs provides a mock function with given fields: ctx, ids
func (_m *ShopItem) GetItemsByIDs(ctx context.Context, ids []uuid.UUID) (map[uuid.UUID]domain.ShopItem, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, ids)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetItemsByIDs")</span>
        }

        <span class="cov8" title="1">var r0 map[uuid.UUID]domain.ShopItem
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, []uuid.UUID) (map[uuid.UUID]domain.ShopItem, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, ids)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, []uuid.UUID) map[uuid.UUID]domain.ShopItem); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, ids)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(map[uuid.UUID]domain.ShopItem)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, []uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, ids)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// NewShopItem creates a new instance of ShopItem. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewShopItem(t interface {
        mock.TestingT
        Cleanup(func())
}) *ShopItem <span class="cov0" title="0">{
        mock := &amp;ShopItem{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">// Code generated by mockery v2.52.2. DO NOT EDIT.

package mocks

import (
        context "context"

        domain "github.com/m11ano/avito-shop/internal/domain"
        mock "github.com/stretchr/testify/mock"

        uuid "github.com/google/uuid"
)

// ShopItemRepository is an autogenerated mock type for the ShopItemRepository type
type ShopItemRepository struct {
        mock.Mock
}

// FindItemByID provides a mock function with given fields: ctx, id
func (_m *ShopItemRepository) FindItemByID(ctx context.Context, id uuid.UUID) (*domain.ShopItem, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for FindItemByID")</span>
        }

        <span class="cov8" title="1">var r0 *domain.ShopItem
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*domain.ShopItem, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, id)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *domain.ShopItem); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*domain.ShopItem)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, id)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// FindItemByName provides a mock function with given fields: ctx, name
func (_m *ShopItemRepository) FindItemByName(ctx context.Context, name string) (*domain.ShopItem, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for FindItemByName")</span>
        }

        <span class="cov8" title="1">var r0 *domain.ShopItem
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (*domain.ShopItem, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, name)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string) *domain.ShopItem); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, name)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*domain.ShopItem)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, name)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// FindItemsByIDs provides a mock function with given fields: ctx, ids
func (_m *ShopItemRepository) FindItemsByIDs(ctx context.Context, ids []uuid.UUID) (map[uuid.UUID]domain.ShopItem, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, ids)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for FindItemsByIDs")</span>
        }

        <span class="cov8" title="1">var r0 map[uuid.UUID]domain.ShopItem
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, []uuid.UUID) (map[uuid.UUID]domain.ShopItem, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, ids)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, []uuid.UUID) map[uuid.UUID]domain.ShopItem); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, ids)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(map[uuid.UUID]domain.ShopItem)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, []uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, ids)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// NewShopItemRepository creates a new instance of ShopItemRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewShopItemRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *ShopItemRepository <span class="cov0" title="0">{
        mock := &amp;ShopItemRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">// Code generated by mockery v2.52.2. DO NOT EDIT.

package mocks

import (
        context "context"

        domain "github.com/m11ano/avito-shop/internal/domain"
        mock "github.com/stretchr/testify/mock"

        usecase "github.com/m11ano/avito-shop/internal/usecase"

        uuid "github.com/google/uuid"
)

// ShopPurchase is an autogenerated mock type for the ShopPurchase type
type ShopPurchase struct {
        mock.Mock
}

// GetInventory provides a mock function with given fields: ctx, accountID
func (_m *ShopPurchase) GetInventory(ctx context.Context, accountID uuid.UUID) ([]usecase.ShopPurchaseGetInventoryItem, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, accountID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetInventory")</span>
        }

        <span class="cov0" title="0">var r0 []usecase.ShopPurchaseGetInventoryItem
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) ([]usecase.ShopPurchaseGetInventoryItem, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, accountID)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) []usecase.ShopPurchaseGetInventoryItem); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, accountID)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]usecase.ShopPurchaseGetInventoryItem)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, accountID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MakePurchase provides a mock function with given fields: ctx, shopItemName, ownerAccountID, quantity, identityKey
func (_m *ShopPurchase) MakePurchase(ctx context.Context, shopItemName string, ownerAccountID uuid.UUID, quantity int64, identityKey *uuid.UUID) (*domain.ShopPurchase, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, shopItemName, ownerAccountID, quantity, identityKey)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for MakePurchase")</span>
        }

        <span class="cov0" title="0">var r0 *domain.ShopPurchase
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, uuid.UUID, int64, *uuid.UUID) (*domain.ShopPurchase, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, shopItemName, ownerAccountID, quantity, identityKey)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, uuid.UUID, int64, *uuid.UUID) *domain.ShopPurchase); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, shopItemName, ownerAccountID, quantity, identityKey)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*domain.ShopPurchase)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, uuid.UUID, int64, *uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, shopItemName, ownerAccountID, quantity, identityKey)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NewShopPurchase creates a new instance of ShopPurchase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewShopPurchase(t interface {
        mock.TestingT
        Cleanup(func())
}) *ShopPurchase <span class="cov0" title="0">{
        mock := &amp;ShopPurchase{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">// Code generated by mockery v2.52.2. DO NOT EDIT.

package mocks

import (
        context "context"

        domain "github.com/m11ano/avito-shop/internal/domain"
        mock "github.com/stretchr/testify/mock"

        usecase "github.com/m11ano/avito-shop/internal/usecase"

        uuid "github.com/google/uuid"
)

// ShopPurchaseRepository is an autogenerated mock type for the ShopPurchaseRepository type
type ShopPurchaseRepository struct {
        mock.Mock
}

// AggrInventoryByAccountID provides a mock function with given fields: ctx, accountID
func (_m *ShopPurchaseRepository) AggrInventoryByAccountID(ctx context.Context, accountID uuid.UUID) ([]usecase.ShopPurchaseRepositoryAggrInventoryItem, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, accountID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for AggrInventoryByAccountID")</span>
        }

        <span class="cov8" title="1">var r0 []usecase.ShopPurchaseRepositoryAggrInventoryItem
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) ([]usecase.ShopPurchaseRepositoryAggrInventoryItem, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, accountID)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) []usecase.ShopPurchaseRepositoryAggrInventoryItem); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, accountID)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).([]usecase.ShopPurchaseRepositoryAggrInventoryItem)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, accountID)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// Create provides a mock function with given fields: ctx, shopPurchase
func (_m *ShopPurchaseRepository) Create(ctx context.Context, shopPurchase *domain.ShopPurchase) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, shopPurchase)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Create")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *domain.ShopPurchase) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, shopPurchase)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// FindIdentity provides a mock function with given fields: ctx, identityKey
func (_m *ShopPurchaseRepository) FindIdentity(ctx context.Context, identityKey uuid.UUID) (bool, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, identityKey)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for FindIdentity")</span>
        }

        <span class="cov8" title="1">var r0 bool
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (bool, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, identityKey)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, identityKey)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, identityKey)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// NewShopPurchaseRepository creates a new instance of ShopPurchaseRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewShopPurchaseRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *ShopPurchaseRepository <span class="cov0" title="0">{
        mock := &amp;ShopPurchaseRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
