
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/m11ano/avito-shop/internal/app/error.go (43.9%)</option>
				
				<option value="file1">github.com/m11ano/avito-shop/internal/app/error_helpers.go (0.0%)</option>
				
				<option value="file2">github.com/m11ano/avito-shop/internal/bootstrap/app.go (0.0%)</option>
				
				<option value="file3">github.com/m11ano/avito-shop/internal/bootstrap/inf_http_fiber.go (0.0%)</option>
				
				<option value="file4">github.com/m11ano/avito-shop/internal/bootstrap/inf_logger.go (0.0%)</option>
				
				<option value="file5">github.com/m11ano/avito-shop/internal/bootstrap/inf_pgxv5.go (0.0%)</option>
				
				<option value="file6">github.com/m11ano/avito-shop/internal/config/config.go (80.0%)</option>
				
				<option value="file7">github.com/m11ano/avito-shop/internal/db/txmngr/provider.go (100.0%)</option>
				
				<option value="file8">github.com/m11ano/avito-shop/internal/db/txmngr/tx_manager.go (100.0%)</option>
				
				<option value="file9">github.com/m11ano/avito-shop/internal/delivery/http/controller/auth.go (0.0%)</option>
				
				<option value="file10">github.com/m11ano/avito-shop/internal/delivery/http/controller/buy.go (0.0%)</option>
				
				<option value="file11">github.com/m11ano/avito-shop/internal/delivery/http/controller/controller.go (0.0%)</option>
				
				<option value="file12">github.com/m11ano/avito-shop/internal/delivery/http/controller/info.go (0.0%)</option>
				
				<option value="file13">github.com/m11ano/avito-shop/internal/delivery/http/controller/send_coin.go (0.0%)</option>
				
				<option value="file14">github.com/m11ano/avito-shop/internal/delivery/http/middleware/auth.go (0.0%)</option>
				
				<option value="file15">github.com/m11ano/avito-shop/internal/delivery/http/middleware/error_handler.go (0.0%)</option>
				
				<option value="file16">github.com/m11ano/avito-shop/internal/delivery/http/middleware/logger.go (0.0%)</option>
				
				<option value="file17">github.com/m11ano/avito-shop/internal/delivery/http/middleware/recovery.go (0.0%)</option>
				
				<option value="file18">github.com/m11ano/avito-shop/internal/delivery/http/middleware/trace_id.go (0.0%)</option>
				
				<option value="file19">github.com/m11ano/avito-shop/internal/delivery/http/register_routes.go (0.0%)</option>
				
				<option value="file20">github.com/m11ano/avito-shop/internal/delivery/http/validation/format_errors.go (0.0%)</option>
				
				<option value="file21">github.com/m11ano/avito-shop/internal/delivery/http/validation/validator.go (0.0%)</option>
				
				<option value="file22">github.com/m11ano/avito-shop/internal/domain/account.go (83.3%)</option>
				
				<option value="file23">github.com/m11ano/avito-shop/internal/domain/coin_transfer.go (0.0%)</option>
				
				<option value="file24">github.com/m11ano/avito-shop/internal/domain/operation.go (0.0%)</option>
				
				<option value="file25">github.com/m11ano/avito-shop/internal/domain/shop_purchase.go (0.0%)</option>
				
				<option value="file26">github.com/m11ano/avito-shop/internal/migrations/goose_logger.go (0.0%)</option>
				
				<option value="file27">github.com/m11ano/avito-shop/internal/migrations/migrate.go (0.0%)</option>
				
				<option value="file28">github.com/m11ano/avito-shop/internal/repository/account.go (0.0%)</option>
				
				<option value="file29">github.com/m11ano/avito-shop/internal/repository/coin_transfer.go (0.0%)</option>
				
				<option value="file30">github.com/m11ano/avito-shop/internal/repository/operation.go (0.0%)</option>
				
				<option value="file31">github.com/m11ano/avito-shop/internal/repository/shop_item.go (0.0%)</option>
				
				<option value="file32">github.com/m11ano/avito-shop/internal/repository/shop_purchase.go (0.0%)</option>
				
				<option value="file33">github.com/m11ano/avito-shop/internal/usecase/account.go (100.0%)</option>
				
				<option value="file34">github.com/m11ano/avito-shop/internal/usecase/auth.go (93.3%)</option>
				
				<option value="file35">github.com/m11ano/avito-shop/internal/usecase/coin_transfer.go (0.0%)</option>
				
				<option value="file36">github.com/m11ano/avito-shop/internal/usecase/operation.go (100.0%)</option>
				
				<option value="file37">github.com/m11ano/avito-shop/internal/usecase/shop_item.go (0.0%)</option>
				
				<option value="file38">github.com/m11ano/avito-shop/internal/usecase/shop_purchase.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package app

import "fmt"

type LogicError struct {
        onlyRead bool
        code     int
        message  string
        details  []string
        wrapErr  []error
        data     any
}

func (e *LogicError) Error() string <span class="cov0" title="0">{
        if len(e.details) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s - details: %v", e.message, e.details)
        }</span>
        <span class="cov0" title="0">return e.message</span>
}

func IsAppError(err error) bool <span class="cov8" title="1">{
        _, ok := err.(*LogicError)
        return ok
}</span>

func NewError(code int, message string, details []string) *LogicError <span class="cov0" title="0">{
        return &amp;LogicError{
                code:    code,
                message: message,
                details: details,
        }
}</span>

func NewErrorFrom(parentErr *LogicError) *LogicError <span class="cov8" title="1">{
        e := &amp;LogicError{
                code:    parentErr.code,
                message: parentErr.message,
                details: parentErr.details,
        }
        return e.Wrap(parentErr)
}</span>

func (e *LogicError) Wrap(err error) *LogicError <span class="cov8" title="1">{
        if e.onlyRead </span><span class="cov0" title="0">{
                return e
        }</span>

        <span class="cov8" title="1">e.wrapErr = append(e.wrapErr, err)
        return e</span>
}

func (e *LogicError) Unwrap() []error <span class="cov8" title="1">{
        return e.wrapErr
}</span>

func (e *LogicError) Is(err error) bool <span class="cov8" title="1">{
        if e == err </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">for _, wErr := range e.wrapErr </span><span class="cov8" title="1">{
                if wErr == err </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (e *LogicError) Lock() *LogicError <span class="cov8" title="1">{
        e.onlyRead = true
        return e
}</span>

func (e *LogicError) Code() int <span class="cov0" title="0">{
        return e.code
}</span>

func (e *LogicError) Message() string <span class="cov0" title="0">{
        return e.message
}</span>

func (e *LogicError) Details() []string <span class="cov0" title="0">{
        return e.details
}</span>

func (e *LogicError) SetMessage(message string) *LogicError <span class="cov8" title="1">{
        if e.onlyRead </span><span class="cov0" title="0">{
                return e
        }</span>
        <span class="cov8" title="1">e.message = message
        return e</span>
}

func (e *LogicError) AddDetails(details []string) *LogicError <span class="cov0" title="0">{
        if e.onlyRead </span><span class="cov0" title="0">{
                return e
        }</span>
        <span class="cov0" title="0">if e.details == nil </span><span class="cov0" title="0">{
                return e
        }</span>
        <span class="cov0" title="0">if e.details == nil </span><span class="cov0" title="0">{
                e.details = make([]string, len(details))
        }</span>
        <span class="cov0" title="0">e.details = append(e.details, details...)
        return e</span>
}

func (e *LogicError) Data() any <span class="cov0" title="0">{
        return e.data
}</span>

func (e *LogicError) SetData(data any) *LogicError <span class="cov0" title="0">{
        if e.onlyRead </span><span class="cov0" title="0">{
                return e
        }</span>

        <span class="cov0" title="0">e.data = data
        return e</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "errors"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

func ErrCheckIsTxСoncurrentExec(err error) bool <span class="cov0" title="0">{
        var pgErr *pgconn.PgError
        if errors.As(err, &amp;pgErr) &amp;&amp; pgErr.Code == "40001" || pgErr.Code == "25P02" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return errors.Is(err, ErrTxСoncurrentExec)</span>
}

func ErrConvertPgxToLogic(err error) (bool, error) <span class="cov0" title="0">{
        if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                return true, NewErrorFrom(ErrStoreNoRows).Wrap(err)
        }</span>
        <span class="cov0" title="0">var pgErr *pgconn.PgError
        if errors.As(err, &amp;pgErr) </span><span class="cov0" title="0">{
                switch </span>{
                case pgErr.Code == "40001":<span class="cov0" title="0">
                        return true, NewErrorFrom(ErrTxСoncurrentExec).Wrap(err)</span>
                case pgErr.Code == "25P02":<span class="cov0" title="0">
                        return true, NewErrorFrom(ErrTxСoncurrentExec).Wrap(err)</span>
                case pgErr.Code == "23505":<span class="cov0" title="0">
                        return true, NewErrorFrom(ErrStoreUniqueViolation).Wrap(err).SetData(pgErr.ColumnName)</span>
                case pgErr.Code == "23503":<span class="cov0" title="0">
                        return true, NewErrorFrom(ErrStoreForeignKeyViolation).Wrap(err).SetData(pgErr.ColumnName)</span>
                case pgErr.Code == "23502":<span class="cov0" title="0">
                        return true, NewErrorFrom(ErrStoreNotNullViolation).Wrap(err).SetData(pgErr.ColumnName)</span>
                case pgErr.Code == "23514":<span class="cov0" title="0">
                        return true, NewErrorFrom(ErrStoreCheckViolation).Wrap(err).SetData(pgErr.ConstraintName)</span>
                case pgErr.Code == "23001":<span class="cov0" title="0">
                        return true, NewErrorFrom(ErrStoreRestrictViolation).Wrap(err).SetData(pgErr.ConstraintName)</span>
                case pgErr.Code == "23000":<span class="cov0" title="0">
                        return true, NewErrorFrom(ErrStoreIntegrityViolation).Wrap(err).SetData(pgErr.ConstraintName)</span>
                default:<span class="cov0" title="0">
                        return false, NewErrorFrom(ErrInternal).Wrap(err)</span>
                }
        }
        <span class="cov0" title="0">return false, err</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package bootstrap

import (
        "context"
        "fmt"
        "log/slog"
        "runtime/debug"
        "time"

        trmpgx "github.com/avito-tech/go-transaction-manager/drivers/pgxv5/v2"
        "github.com/avito-tech/go-transaction-manager/trm/v2/manager"
        "github.com/gofiber/fiber/v2"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/m11ano/avito-shop/internal/config"
        "github.com/m11ano/avito-shop/internal/db/txmngr"
        "github.com/m11ano/avito-shop/internal/migrations"
        "go.uber.org/fx"
)

var App = fx.Options(
        // Инфраструктура
        fx.Provide(NewLogger),
        fx.Provide(NewPgxv5),
        fx.Provide(func(config config.Config, logger *slog.Logger) *fiber.App <span class="cov0" title="0">{
                fiberApp := NewHTTPFiber(HTTPConfig{
                        UnderProxy: config.HTTP.UnderProxy,
                        UseTraceID: true,
                        UseLogger:  true,
                }, logger)
                return fiberApp
        }</span>),
        fx.Provide(func(pgxpool *pgxpool.Pool) (*manager.Manager, *trmpgx.CtxGetter) <span class="cov0" title="0">{
                return txmngr.New(pgxpool)
        }</span>),
        // Бизнес логика
        AccountModule,
        OperationModule,
        AuthModule,
        ShopItemModule,
        ShopPurchaseModule,
        CoinTransferModule,
        // Delivery
        DeliveryHTTP,
        // Start &amp;&amp; Stop invoke
        fx.Invoke(func(lc fx.Lifecycle, shutdowner fx.Shutdowner, logger *slog.Logger, config config.Config, dbpool *pgxpool.Pool, fiberApp *fiber.App) <span class="cov0" title="0">{
                lc.Append(fx.Hook{
                        OnStart: func(ctx context.Context) error </span><span class="cov0" title="0">{
                                err := Pgxv5TestConnection(ctx, dbpool, logger, config.DB.MaxAttempt, config.DB.AttemptSleepSeconds)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">logger.Info("Postgress connected")

                                err = migrations.RunMigrations(ctx, dbpool, logger)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                                        if err := fiberApp.Listen(fmt.Sprintf(":%d", config.HTTP.Port)); err != nil </span><span class="cov0" title="0">{
                                                logger.Error("failed to start fiber", slog.Any("error", err), slog.Any("trackeback", string(debug.Stack())))
                                                err := shutdowner.Shutdown()
                                                if err != nil </span><span class="cov0" title="0">{
                                                        logger.Error("failed to shutdown", slog.Any("error", err), slog.Any("trackeback", string(debug.Stack())))
                                                }</span>
                                        }
                                }()

                                <span class="cov0" title="0">return nil</span>
                        },
                        OnStop: func(_ context.Context) error <span class="cov0" title="0">{
                                logger.Info("stopping HTTP Fiber")
                                err := fiberApp.ShutdownWithTimeout(time.Duration(config.HTTP.StopTimeout) * time.Second)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Error("failed to stop fiber", slog.Any("error", err), slog.Any("trackeback", string(debug.Stack())))
                                }</span>

                                <span class="cov0" title="0">logger.Info("stopping Postgress")
                                dbpool.Close()

                                return nil</span>
                        },
                })
        }),
)
</pre>
		
		<pre class="file" id="file3" style="display: none">package bootstrap

import (
        "log/slog"

        "github.com/gofiber/fiber/v2"
        "github.com/m11ano/avito-shop/internal/delivery/http/middleware"
)

type HTTPConfig struct {
        UnderProxy bool
        UseTraceID bool
        UseLogger  bool
}

func NewHTTPFiber(httpCfg HTTPConfig, logger *slog.Logger) *fiber.App <span class="cov0" title="0">{
        fiberCfg := fiber.Config{
                ErrorHandler: middleware.ErrorHandler(),
        }

        if httpCfg.UnderProxy </span><span class="cov0" title="0">{
                fiberCfg.ProxyHeader = fiber.HeaderXForwardedFor
        }</span>

        <span class="cov0" title="0">app := fiber.New(fiberCfg)

        app.Use(middleware.Recovery(logger))

        if httpCfg.UseTraceID </span><span class="cov0" title="0">{
                app.Use(middleware.TraceID())
        }</span>

        <span class="cov0" title="0">if httpCfg.UseLogger </span><span class="cov0" title="0">{
                app.Use(middleware.Logger(logger))
        }</span>

        <span class="cov0" title="0">return app</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package bootstrap

import (
        "log/slog"
        "os"

        "github.com/m11ano/avito-shop/internal/config"
)

func NewLogger(config config.Config) *slog.Logger <span class="cov0" title="0">{
        var handler slog.Handler
        if !config.App.IsProd </span><span class="cov0" title="0">{
                handler = slog.NewTextHandler(os.Stdout, nil)
        }</span> else<span class="cov0" title="0"> {
                handler = slog.NewJSONHandler(os.Stdout, nil)
        }</span>
        <span class="cov0" title="0">logger := slog.New(handler)
        return logger</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package bootstrap

import (
        "context"
        "fmt"
        "log/slog"
        "time"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/m11ano/avito-shop/internal/config"
)

type pgxv5Tracer struct {
        logger *slog.Logger
}

func (t *pgxv5Tracer) TraceQueryStart(ctx context.Context, _ *pgx.Conn, data pgx.TraceQueryStartData) context.Context <span class="cov0" title="0">{
        t.logger.Info(fmt.Sprintf("Начало запроса: %s, args: %v", data.SQL, data.Args))
        return ctx
}</span>

func (t *pgxv5Tracer) TraceQueryEnd(_ context.Context, _ *pgx.Conn, data pgx.TraceQueryEndData) <span class="cov0" title="0">{
        t.logger.Info(fmt.Sprintf("Завершение запроса: %s, ошибка: %v", data.CommandTag, data.Err))
}</span>

func NewPgxv5(config config.Config, logger *slog.Logger) *pgxpool.Pool <span class="cov0" title="0">{
        ctx := context.Background()
        pgxCfg, err := pgxpool.ParseConfig(config.DB.URI)
        if err != nil </span><span class="cov0" title="0">{
                panic("unable to parse db uri string")</span>
        }

        <span class="cov0" title="0">if !config.App.IsProd </span><span class="cov0" title="0">{
                pgxCfg.ConnConfig.Tracer = &amp;pgxv5Tracer{logger: logger}
        }</span>

        <span class="cov0" title="0">dbpool, err := pgxpool.NewWithConfig(ctx, pgxCfg)
        if err != nil </span><span class="cov0" title="0">{
                panic("unable to create pgxv5 connection pool")</span>
        }

        <span class="cov0" title="0">return dbpool</span>
}

func Pgxv5TestConnection(ctx context.Context, dbpool *pgxpool.Pool, logger *slog.Logger, maxAttempt int, attemptSleepSeconds int) error <span class="cov0" title="0">{
        attemp := 1
        var err error
        for attemp &lt;= maxAttempt </span><span class="cov0" title="0">{
                err = dbpool.Ping(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Info("failed to connect to Postgress", slog.Int("attemp", attemp))
                        time.Sleep(time.Duration(attemptSleepSeconds) * time.Second)
                        attemp++
                        continue</span>
                }
                <span class="cov0" title="0">break</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "log"

        "github.com/ilyakaznacheev/cleanenv"
)

type Config struct {
        App struct {
                StartTimeout int  `yaml:"start_timeout" env:"APP_START_TIMEOUT" env-default:"60"`
                StopTimeout  int  `yaml:"stop_timeout" env:"APP_STOP_TIMEOUT" env-default:"10"`
                IsProd       bool `yaml:"is_prod" env:"APP_IS_PROD" env-default:"false"`
        } `yaml:"app"`
        DB struct {
                URI                 string `yaml:"uri" env:"DB_URI"`
                MaxAttempt          int    `yaml:"max_attempts" env:"DB_MAX_ATTEMPTS" env-default:"10"`
                AttemptSleepSeconds int    `yaml:"attempt_sleep_seconds" env:"DB_ATTEMPT_SLEEP_SECONDS" env-default:"3"`
        } `yaml:"db"`
        HTTP struct {
                Prefix      string `yaml:"prefix" env:"HTTP_PREFIX" env-default:"api"`
                Port        int    `yaml:"port" env:"HTTP_PORT" env-default:"8080"`
                StopTimeout int    `yaml:"stop_timeout" env:"HTTP_STOP_TIMEOUT" env-default:"5"`
                UnderProxy  bool   `yaml:"under_proxy" env:"HTTP_UNDER_PROXY" env-default:"false"`
        }
        Auth struct {
                JWTSecretKey     string `yaml:"jwt_secret_key" env:"AUTH_JWT_SECRET_KEY" env-default:""`
                JWTTokenTTL      int64  `yaml:"jwt_token_ttl" env:"AUTH_JWT_TOKEN_TTL" env-default:"3600"`
                NewAccountAmount int64  `yaml:"new_account_amount" env:"AUTH_NEW_ACCOUNT_AMOUNT" env-default:"0"`
        }
}

func LoadConfig(file string) Config <span class="cov8" title="1">{
        //
        var Config Config

        err := cleanenv.ReadConfig(file, &amp;Config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("config error", err)
        }</span>

        <span class="cov8" title="1">return Config</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package txmngr

import (
        trmpgx "github.com/avito-tech/go-transaction-manager/drivers/pgxv5/v2"
        "github.com/avito-tech/go-transaction-manager/trm/v2/manager"
        "github.com/m11ano/avito-shop/internal/db"
)

func NewProvider(dbpool db.PgxPool) func() (*manager.Manager, *trmpgx.CtxGetter) <span class="cov8" title="1">{
        return func() (*manager.Manager, *trmpgx.CtxGetter) </span><span class="cov8" title="1">{
                return New(dbpool)
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package txmngr

import (
        trmpgx "github.com/avito-tech/go-transaction-manager/drivers/pgxv5/v2"
        "github.com/avito-tech/go-transaction-manager/trm/v2/manager"
        "github.com/avito-tech/go-transaction-manager/trm/v2/settings"
        "github.com/jackc/pgx/v5"
        "github.com/m11ano/avito-shop/internal/db"
)

func New(dbpool db.PgxPool) (*manager.Manager, *trmpgx.CtxGetter) <span class="cov8" title="1">{
        txOptions := pgx.TxOptions{
                IsoLevel: pgx.RepeatableRead, // Устанавливаем уровень изоляции RepeatableRead
        }

        settingsOpts := settings.Must()

        trmpgxSettings := trmpgx.MustSettings(settingsOpts, trmpgx.WithTxOptions(txOptions))

        txFactory := trmpgx.NewFactory(dbpool)

        txManager := manager.Must(txFactory, manager.WithSettings(trmpgxSettings))

        return txManager, trmpgx.DefaultCtxGetter
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package controller

import (
        "errors"

        "github.com/gofiber/fiber/v2"
        "github.com/m11ano/avito-shop/internal/app"
        "github.com/m11ano/avito-shop/internal/delivery/http/validation"
)

type AuthHandlerOut struct {
        Token string `json:"token"`
}

type AuthHandlerIn struct {
        Username string `json:"username" validate:"required,max=255"`
        Password string `json:"password" validate:"required,max=255"`
}

func (ctrl *Controller) AuthHandlerValidate(in *AuthHandlerIn) (isOk bool, errMsg string) <span class="cov0" title="0">{
        if err := ctrl.vldtr.Struct(in); err != nil </span><span class="cov0" title="0">{
                return validation.FormatErrors(err)
        }</span>
        <span class="cov0" title="0">return true, ""</span>
}

func (ctrl *Controller) AuthHandler(c *fiber.Ctx) error <span class="cov0" title="0">{
        in := &amp;AuthHandlerIn{}

        if err := c.BodyParser(in); err != nil </span><span class="cov0" title="0">{
                return &amp;fiber.Error{Code: fiber.ErrBadRequest.Code, Message: err.Error()}
        }</span>

        <span class="cov0" title="0">ok, errMsg := ctrl.AuthHandlerValidate(in)
        if !ok </span><span class="cov0" title="0">{
                return &amp;fiber.Error{Code: fiber.ErrBadRequest.Code, Message: errMsg}
        }</span>

        <span class="cov0" title="0">jwtToken, err := ctrl.usecaseAuth.SignInOrSignUp(c.Context(), in.Username, in.Password)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, app.ErrInternal) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return app.ErrUnauthorized</span>
        }

        <span class="cov0" title="0">out := AuthHandlerOut{Token: jwtToken}

        return c.JSON(out)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package controller

import (
        "errors"

        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "github.com/m11ano/avito-shop/internal/app"
        "github.com/m11ano/avito-shop/internal/usecase"
)

func (ctrl *Controller) BuyHandler(c *fiber.Ctx) error <span class="cov0" title="0">{
        if isAuth, ok := c.Locals("isAuth").(bool); !ok || !isAuth </span><span class="cov0" title="0">{
                return app.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">var accountID *uuid.UUID
        var ok bool
        if accountID, ok = c.Locals("authAccountID").(*uuid.UUID); !ok </span><span class="cov0" title="0">{
                return app.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">var requestID *uuid.UUID
        if requestID, ok = c.Locals("requestID").(*uuid.UUID); !ok </span><span class="cov0" title="0">{
                return app.ErrInternal
        }</span>

        <span class="cov0" title="0">shopItemName := c.Params("name")

        _, err := ctrl.usecaseShopPurchase.MakePurchase(c.Context(), shopItemName, *accountID, 1, requestID)
        if err != nil </span><span class="cov0" title="0">{
                // Маппинг ошибок под требования контракта
                switch </span>{
                case errors.Is(err, usecase.ErrOperationNotEnoughFunds):<span class="cov0" title="0">
                        return app.NewErrorFrom(app.ErrBadRequest).SetMessage(err.Error())</span>
                case errors.Is(err, app.ErrConflict):<span class="cov0" title="0">
                        return app.NewErrorFrom(app.ErrBadRequest).SetMessage(err.Error())</span>
                case errors.Is(err, app.ErrNotFound):<span class="cov0" title="0">
                        return app.NewErrorFrom(app.ErrBadRequest).SetMessage(err.Error())</span>
                default:<span class="cov0" title="0">
                        return err</span>
                }
        }

        <span class="cov0" title="0">return c.SendStatus(fiber.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package controller

import (
        "github.com/go-playground/validator/v10"
        "github.com/m11ano/avito-shop/internal/usecase"
)

type Controller struct {
        vldtr               *validator.Validate
        usecaseAuth         usecase.Auth
        usecaseOperation    usecase.Operation
        usecaseShopPurchase usecase.ShopPurchase
        usecaseCoinTransfer usecase.CoinTransfer
}

func New(vldtr *validator.Validate, usecaseAuth usecase.Auth, usecaseOperation usecase.Operation, usecaseShopPurchase usecase.ShopPurchase, usecaseCoinTransfer usecase.CoinTransfer) *Controller <span class="cov0" title="0">{
        return &amp;Controller{
                vldtr:               vldtr,
                usecaseAuth:         usecaseAuth,
                usecaseOperation:    usecaseOperation,
                usecaseShopPurchase: usecaseShopPurchase,
                usecaseCoinTransfer: usecaseCoinTransfer,
        }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package controller

import (
        "fmt"

        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "github.com/m11ano/avito-shop/internal/app"
        "github.com/m11ano/avito-shop/internal/domain"
)

type InfoHandlerOut struct {
        Coins       int64                     `json:"coins"`
        Inventory   []InfoHandlerOutInventory `json:"inventory"`
        CoinHistory InfoHandlerOutCoinHistory `json:"coinHistory"`
}

type InfoHandlerOutInventory struct {
        Type     string `json:"type"`
        Quantity int64  `json:"quantity"`
}

type InfoHandlerOutCoinHistory struct {
        Received []InfoHandlerOutCoinHistoryReceived `json:"received"`
        Sent     []InfoHandlerOutCoinHistorySent     `json:"sent"`
}

type InfoHandlerOutCoinHistorySent struct {
        ToUser string `json:"toUser"`
        Amount int64  `json:"amount"`
}

type InfoHandlerOutCoinHistoryReceived struct {
        FromUser string `json:"fromUser"`
        Amount   int64  `json:"amount"`
}

func (ctrl *Controller) InfoHandler(c *fiber.Ctx) error <span class="cov0" title="0">{
        if isAuth, ok := c.Locals("isAuth").(bool); !ok || !isAuth </span><span class="cov0" title="0">{
                return app.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">var accountID *uuid.UUID
        var ok bool
        if accountID, ok = c.Locals("authAccountID").(*uuid.UUID); !ok </span><span class="cov0" title="0">{
                return app.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">var err error
        out := InfoHandlerOut{}

        // Получаем баланс пользователя
        out.Coins, _, err = ctrl.usecaseOperation.GetBalanceByAccountID(c.Context(), *accountID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("!!!", err)
                return err
        }</span>

        // Получаем инвентарь и перекладываем в дто ответа
        <span class="cov0" title="0">inventory, err := ctrl.usecaseShopPurchase.GetInventory(c.Context(), *accountID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">out.Inventory = make([]InfoHandlerOutInventory, 0, len(inventory))
        for _, item := range inventory </span><span class="cov0" title="0">{
                invItem := InfoHandlerOutInventory{
                        Quantity: item.Quantity,
                }
                if item.ShopItem != nil </span><span class="cov0" title="0">{
                        invItem.Type = item.ShopItem.Name
                }</span>
                <span class="cov0" title="0">out.Inventory = append(out.Inventory, invItem)</span>
        }

        // Получаем агрегированную историю полученных монет и перекладываем в дто ответа
        <span class="cov0" title="0">receivedCoinHistory, err := ctrl.usecaseCoinTransfer.GetAggrCoinHistory(c.Context(), *accountID, domain.CoinTransferTypeReciving)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">out.CoinHistory.Received = make([]InfoHandlerOutCoinHistoryReceived, 0, len(receivedCoinHistory))
        for _, item := range receivedCoinHistory </span><span class="cov0" title="0">{
                out.CoinHistory.Received = append(out.CoinHistory.Received, InfoHandlerOutCoinHistoryReceived{
                        FromUser: item.Account.Username,
                        Amount:   item.Amount,
                })
        }</span>

        // Получаем агрегированную историю отправленных монет и перекладываем в дто ответа
        <span class="cov0" title="0">sentCoinHistory, err := ctrl.usecaseCoinTransfer.GetAggrCoinHistory(c.Context(), *accountID, domain.CoinTransferTypeSending)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">out.CoinHistory.Sent = make([]InfoHandlerOutCoinHistorySent, 0, len(sentCoinHistory))
        for _, item := range sentCoinHistory </span><span class="cov0" title="0">{
                out.CoinHistory.Sent = append(out.CoinHistory.Sent, InfoHandlerOutCoinHistorySent{
                        ToUser: item.Account.Username,
                        Amount: item.Amount,
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(out)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package controller

import (
        "errors"

        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "github.com/m11ano/avito-shop/internal/app"
        "github.com/m11ano/avito-shop/internal/delivery/http/validation"
        "github.com/m11ano/avito-shop/internal/usecase"
)

type SendCoinIn struct {
        ToUser string `json:"toUser" validate:"required"`
        Amount int64  `json:"amount" validate:"gt=0"`
}

func (ctrl *Controller) SendCoinValidate(in *SendCoinIn) (bool, string) <span class="cov0" title="0">{
        if err := ctrl.vldtr.Struct(in); err != nil </span><span class="cov0" title="0">{
                return validation.FormatErrors(err)
        }</span>
        <span class="cov0" title="0">return true, ""</span>
}

func (ctrl *Controller) SendCoinHandler(c *fiber.Ctx) error <span class="cov0" title="0">{
        if isAuth, ok := c.Locals("isAuth").(bool); !ok || !isAuth </span><span class="cov0" title="0">{
                return app.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">in := &amp;SendCoinIn{}

        if err := c.BodyParser(in); err != nil </span><span class="cov0" title="0">{
                return &amp;fiber.Error{Code: fiber.ErrBadRequest.Code, Message: err.Error()}
        }</span>

        <span class="cov0" title="0">var ok bool

        ok, errMsg := ctrl.SendCoinValidate(in)
        if !ok </span><span class="cov0" title="0">{
                return &amp;fiber.Error{Code: fiber.ErrBadRequest.Code, Message: errMsg}
        }</span>

        <span class="cov0" title="0">var accountID *uuid.UUID
        if accountID, ok = c.Locals("authAccountID").(*uuid.UUID); !ok </span><span class="cov0" title="0">{
                return app.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">var requestID *uuid.UUID
        if requestID, ok = c.Locals("requestID").(*uuid.UUID); !ok </span><span class="cov0" title="0">{
                return app.ErrInternal
        }</span>

        <span class="cov0" title="0">_, _, err := ctrl.usecaseCoinTransfer.MakeTransferByUsername(c.Context(), in.ToUser, *accountID, in.Amount, requestID)
        if err != nil </span><span class="cov0" title="0">{
                // Маппинг ошибок под требования контракта
                switch </span>{
                case errors.Is(err, usecase.ErrOperationNotEnoughFunds):<span class="cov0" title="0">
                        return app.NewErrorFrom(app.ErrBadRequest).SetMessage(err.Error())</span>
                case errors.Is(err, app.ErrConflict):<span class="cov0" title="0">
                        return app.NewErrorFrom(app.ErrBadRequest).SetMessage(err.Error())</span>
                case errors.Is(err, app.ErrNotFound):<span class="cov0" title="0">
                        return app.NewErrorFrom(app.ErrBadRequest).SetMessage(err.Error())</span>
                default:<span class="cov0" title="0">
                        return err</span>
                }
        }

        <span class="cov0" title="0">return c.SendStatus(fiber.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package middleware

import (
        "errors"
        "strings"

        "github.com/gofiber/fiber/v2"
        "github.com/m11ano/avito-shop/internal/app"
        "github.com/m11ano/avito-shop/internal/usecase"
)

func Auth(authUsecase usecase.Auth) func(*fiber.Ctx) error <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                isAuth := false

                AuthorizationHeader := strings.TrimPrefix(c.Get("Authorization"), "Bearer ")

                if len(AuthorizationHeader) &gt; 0 </span><span class="cov0" title="0">{
                        accountID, err := authUsecase.AuthByJWTToken(c.Context(), AuthorizationHeader)
                        if err != nil &amp;&amp; !errors.Is(err, app.ErrUnauthorized) </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if accountID != nil </span><span class="cov0" title="0">{
                                isAuth = true
                                c.Locals("authAccountID", accountID)
                        }</span>
                }

                <span class="cov0" title="0">c.Locals("isAuth", isAuth)

                return c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package middleware

import (
        "github.com/gofiber/fiber/v2"
        "github.com/m11ano/avito-shop/internal/app"
)

type errorJSON struct {
        Errors string `json:"errors"`
}

func ErrorHandler() func(*fiber.Ctx, error) error <span class="cov0" title="0">{
        return func(c *fiber.Ctx, err error) error </span><span class="cov0" title="0">{
                json := errorJSON{}
                code := 500

                switch errTyped := err.(type) </span>{
                case *app.LogicError:<span class="cov0" title="0">
                        code = errTyped.Code()
                        json.Errors = errTyped.Error()</span>
                case *fiber.Error:<span class="cov0" title="0">
                        code = errTyped.Code
                        json.Errors = err.Error()</span>
                default:<span class="cov0" title="0">
                        json.Errors = "internal error"</span>
                }

                <span class="cov0" title="0">return c.Status(code).JSON(json)</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package middleware

import (
        "context"
        "log/slog"
        "runtime/debug"

        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
)

type LogRequestData struct {
        Method    string `json:"method"`
        Path      string `json:"path"`
        IP        string `json:"ip"`
        URI       string `json:"uri"`
        RequestID string `json:"requestId,omitempty"`
}

func Logger(logger *slog.Logger) func(*fiber.Ctx) error <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                result := c.Next()

                if result != nil </span><span class="cov0" title="0">{
                        err := c.App().ErrorHandler(c, result)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.ErrorContext(c.Context(), "failed to call fiber error handler", slog.Any("error", err), slog.Any("trackeback", string(debug.Stack())))
                        }</span>
                }

                <span class="cov0" title="0">code := c.Response().StatusCode()

                logRequestData := LogRequestData{
                        Method: c.Method(),
                        Path:   c.Path(),
                        IP:     c.IP(),
                        URI:    string(c.Context().URI().QueryString()),
                }

                requestID := c.Locals("requestID")
                if requestID, ok := requestID.(*uuid.UUID); ok </span><span class="cov0" title="0">{
                        logRequestData.RequestID = requestID.String()
                }</span>

                <span class="cov0" title="0">go doLogging(c.Context(), logger, code, logRequestData)

                return nil</span>
        }
}

func doLogging(ctx context.Context, logger *slog.Logger, code int, data LogRequestData) <span class="cov0" title="0">{
        if code &gt;= 400 </span><span class="cov0" title="0">{
                logger.ErrorContext(
                        ctx,
                        "http response: error",
                        slog.Int("reponseCode", code),
                        slog.Any("request", data),
                )
        }</span> else<span class="cov0" title="0"> {
                logger.InfoContext(
                        ctx,
                        "http response: success",
                        slog.Int("reponseCode", code),
                        slog.Any("request", data),
                )
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package middleware

import (
        "errors"
        "fmt"
        "log/slog"
        "runtime/debug"

        "github.com/gofiber/fiber/v2"
)

func Recovery(logger *slog.Logger) func(*fiber.Ctx) error <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if errRec := recover(); errRec != nil </span><span class="cov0" title="0">{
                                var err error
                                switch errData := errRec.(type) </span>{
                                case error:<span class="cov0" title="0">
                                        err = errData</span>
                                case string:<span class="cov0" title="0">
                                        err = fmt.Errorf("panic: %s", errData)</span>
                                default:<span class="cov0" title="0">
                                        err = errors.New("panic: unknown error happend")</span>
                                }

                                <span class="cov0" title="0">handlerErr := c.App().ErrorHandler(c, err)
                                if handlerErr != nil </span><span class="cov0" title="0">{
                                        logger.ErrorContext(c.Context(), "failed to call fiber error handler", slog.Any("error", handlerErr), slog.Any("trackeback", string(debug.Stack())))
                                }</span>

                                <span class="cov0" title="0">logger.ErrorContext(c.Context(), "panic inside http request", slog.Any("error", err), slog.Any("trackeback", string(debug.Stack())))</span>
                        }
                }()

                <span class="cov0" title="0">return c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package middleware

import (
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
)

func TraceID() func(*fiber.Ctx) error <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                requestID, err := uuid.Parse(c.Get("X-Request-ID"))
                if err != nil </span><span class="cov0" title="0">{
                        requestID = uuid.New()
                }</span>

                <span class="cov0" title="0">c.Locals("requestID", &amp;requestID)

                return c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package http

import (
        "github.com/gofiber/fiber/v2"
        "github.com/m11ano/avito-shop/internal/config"
        "github.com/m11ano/avito-shop/internal/delivery/http/controller"
        "github.com/m11ano/avito-shop/internal/delivery/http/middleware"
        "github.com/m11ano/avito-shop/internal/usecase"
)

func RegisterRoutes(app *fiber.App, config config.Config, ctrl *controller.Controller, authUsecase usecase.Auth) <span class="cov0" title="0">{
        authMiddleware := middleware.Auth(authUsecase)
        rootGroup := app.Group(config.HTTP.Prefix, authMiddleware)

        rootGroup.Post("/auth", ctrl.AuthHandler)
        rootGroup.Get("/info", ctrl.InfoHandler)
        rootGroup.Get("/buy/:name", ctrl.BuyHandler)
        rootGroup.Post("/sendCoin", ctrl.SendCoinHandler)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package validation

import (
        "strings"

        "github.com/go-playground/validator/v10"
)

func FormatErrors(err error) (bool, string) <span class="cov0" title="0">{
        errors := make([]string, 0)
        if validationErrors, ok := err.(validator.ValidationErrors); ok </span><span class="cov0" title="0">{
                for _, e := range validationErrors </span><span class="cov0" title="0">{
                        errors = append(errors, e.Error())
                }</span>
        }

        <span class="cov0" title="0">if len(errors) == 0 </span><span class="cov0" title="0">{
                return true, ""
        }</span>

        <span class="cov0" title="0">return false, strings.Join(errors, "; ")</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package validation

import (
        "github.com/go-playground/validator/v10"
)

func NewValidator() *validator.Validate <span class="cov0" title="0">{
        validate := validator.New()
        return validate
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package domain

import (
        "time"

        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"
)

type Account struct {
        ID           uuid.UUID
        Username     string
        PasswordHash string
        CreatedAt    time.Time
        UpdatedAt    time.Time
}

func (a *Account) GeneretePasswordHash(password string) error <span class="cov8" title="1">{
        hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.MinCost)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">a.PasswordHash = string(hash)

        return nil</span>
}

func (a *Account) VerifyPassword(password string) bool <span class="cov8" title="1">{
        err := bcrypt.CompareHashAndPassword([]byte(a.PasswordHash), []byte(password))
        return err == nil
}</span>

// New account with text password, hash will be generated automatically
func NewAccount(username string, password string) (*Account, error) <span class="cov8" title="1">{
        account := &amp;Account{
                ID:        uuid.New(),
                Username:  username,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }

        err := account.GeneretePasswordHash(password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return account, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package domain

import (
        "time"

        "github.com/google/uuid"
)

type CoinTransferType int8

const (
        CoinTransferTypeSending CoinTransferType = iota + 1
        CoinTransferTypeReciving
)

type CoinTransfer struct {
        ID                    uuid.UUID
        Type                  CoinTransferType
        OwnerAccountID        uuid.UUID
        CounterpartyAccountID uuid.UUID
        Amount                int64
        CreatedAt             time.Time
        IdentityKey           *uuid.UUID
}

func NewCoinTransfer(transferType CoinTransferType, counterpartyAccountID uuid.UUID, ownerAccountID uuid.UUID, amount int64, identityKey *uuid.UUID) *CoinTransfer <span class="cov0" title="0">{
        return &amp;CoinTransfer{
                ID:                    uuid.New(),
                Type:                  transferType,
                OwnerAccountID:        ownerAccountID,
                CounterpartyAccountID: counterpartyAccountID,
                Amount:                amount,
                CreatedAt:             time.Now(),
                IdentityKey:           identityKey,
        }
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package domain

import (
        "time"

        "github.com/google/uuid"
)

type OperationType int8

const (
        OperationTypeIncrease OperationType = iota + 1
        OperationTypeDecrease
)

type OperationSourceType int8

const (
        OperationSourceTypeDeposit OperationSourceType = iota + 1
        OperationSourceTypeShopPurchase
        OperationSourceTypeTransfer
)

type Operation struct {
        ID         uuid.UUID
        Type       OperationType
        AccountID  uuid.UUID
        Amount     int64
        SourceType OperationSourceType
        SourceID   *uuid.UUID
        CreatedAt  time.Time
}

func NewOperation(opertationType OperationType, accountID uuid.UUID, amount int64, sourceType OperationSourceType, sourceID *uuid.UUID) *Operation <span class="cov0" title="0">{
        return &amp;Operation{
                ID:         uuid.New(),
                Type:       opertationType,
                AccountID:  accountID,
                Amount:     amount,
                SourceType: sourceType,
                SourceID:   sourceID,
                CreatedAt:  time.Now(),
        }
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package domain

import (
        "time"

        "github.com/google/uuid"
)

type ShopPurchase struct {
        ID          uuid.UUID
        ItemID      uuid.UUID
        AccountID   uuid.UUID
        Quantity    int64
        CreatedAt   time.Time
        IdentityKey *uuid.UUID
}

func NewShopPurchase(itemID uuid.UUID, accountID uuid.UUID, quantity int64, identityKey *uuid.UUID) *ShopPurchase <span class="cov0" title="0">{
        return &amp;ShopPurchase{
                ID:          uuid.New(),
                ItemID:      itemID,
                AccountID:   accountID,
                Quantity:    quantity,
                CreatedAt:   time.Now(),
                IdentityKey: identityKey,
        }
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package migrations

import (
        "fmt"
        "log/slog"
)

type SlogLogger struct {
        logger *slog.Logger
}

func NewSlogLogger(logger *slog.Logger) *SlogLogger <span class="cov0" title="0">{
        return &amp;SlogLogger{
                logger: logger,
        }
}</span>

func (l *SlogLogger) Fatalf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.logger.Error(fmt.Sprintf(format, v...))
}</span>

func (l *SlogLogger) Printf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.logger.Info(fmt.Sprintf(format, v...))
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package migrations

import (
        "context"
        "log/slog"

        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/jackc/pgx/v5/stdlib"
        "github.com/pressly/goose/v3"
)

func RunMigrations(_ context.Context, pool *pgxpool.Pool, logger *slog.Logger) error <span class="cov0" title="0">{
        if err := goose.SetDialect("postgres"); err != nil </span><span class="cov0" title="0">{
                logger.Error("goose: unable to set dialect", slog.Any("error", err))
                return err
        }</span>
        <span class="cov0" title="0">goose.SetLogger(NewSlogLogger(logger))

        db := stdlib.OpenDBFromPool(pool)
        if err := goose.Up(db, "migrations"); err != nil </span><span class="cov0" title="0">{
                logger.Error("goose: unable to run migrations", slog.Any("error", err))
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package repository

import (
        "context"
        "log/slog"
        "time"

        "github.com/Masterminds/squirrel"
        trmpgx "github.com/avito-tech/go-transaction-manager/drivers/pgxv5/v2"
        "github.com/georgysavva/scany/v2/pgxscan"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/m11ano/avito-shop/internal/app"
        "github.com/m11ano/avito-shop/internal/domain"
        "github.com/m11ano/avito-shop/pkg/dbhelper"
)

const (
        accountTable = "account"
)

type DBAccount struct {
        ID           uuid.UUID `db:"account_id"`
        Username     string    `db:"username"`
        PasswordHash string    `db:"password_hash"`
        CreatedAt    time.Time `db:"created_at"`
        UpdatedAt    time.Time `db:"updated_at"`
}

var (
        accountTableFields = []string{}
        accountDBSchema    = &amp;DBAccount{}
)

func init() <span class="cov0" title="0">{
        accountTableFields = dbhelper.ExtractDBFields(accountDBSchema)
}</span>

type Account struct {
        logger *slog.Logger
        db     *pgxpool.Pool
        txc    *trmpgx.CtxGetter
        qb     squirrel.StatementBuilderType
}

func NewAccount(logger *slog.Logger, db *pgxpool.Pool, txc *trmpgx.CtxGetter) *Account <span class="cov0" title="0">{
        return &amp;Account{
                logger: logger,
                db:     db,
                txc:    txc,
                qb:     squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar),
        }
}</span>

func (r *Account) dbToDomain(db *DBAccount) *domain.Account <span class="cov0" title="0">{
        return &amp;domain.Account{
                ID:           db.ID,
                Username:     db.Username,
                PasswordHash: db.PasswordHash,
                CreatedAt:    db.CreatedAt,
                UpdatedAt:    db.UpdatedAt,
        }
}</span>

func (r *Account) FindItemByUsername(ctx context.Context, username string) (*domain.Account, error) <span class="cov0" title="0">{
        query, args, err := r.qb.Select(accountTableFields...).From(accountTable).Where(squirrel.Eq{"username": username}).Limit(1).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return nil, app.NewErrorFrom(app.ErrInternal).Wrap(err)
        }</span>

        <span class="cov0" title="0">rows, err := r.txc.DefaultTrOrDB(ctx, r.db).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov0" title="0">defer rows.Close()

        dbData := &amp;DBAccount{}

        if err := pgxscan.ScanOne(dbData, rows); err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov0" title="0">item := r.dbToDomain(dbData)

        return item, nil</span>
}

func (r *Account) FindItemsByIDs(ctx context.Context, ids []uuid.UUID) (map[uuid.UUID]domain.Account, error) <span class="cov0" title="0">{
        query, args, err := r.qb.Select(accountTableFields...).From(accountTable).Where(squirrel.Eq{"account_id": ids}).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return nil, app.NewErrorFrom(app.ErrInternal).Wrap(err)
        }</span>

        <span class="cov0" title="0">rows, err := r.txc.DefaultTrOrDB(ctx, r.db).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov0" title="0">defer rows.Close()

        result := map[uuid.UUID]domain.Account{}

        for rows.Next() </span><span class="cov0" title="0">{
                data := &amp;DBAccount{}
                if err := pgxscan.ScanRow(data, rows); err != nil </span><span class="cov0" title="0">{
                        errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                        if !errIsConv </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return nil, convErr</span>
                }
                <span class="cov0" title="0">domainItem := *r.dbToDomain(data)
                result[domainItem.ID] = domainItem</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func (r *Account) Create(ctx context.Context, item *domain.Account) error <span class="cov0" title="0">{
        dataMap, err := dbhelper.StructToDBMap(item, accountDBSchema)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "convert struct to db map", slog.Any("error", err))
                return app.NewErrorFrom(app.ErrInternal).Wrap(err)
        }</span>
        <span class="cov0" title="0">dataMap["updated_at"] = time.Now()

        query, args, err := r.qb.Insert(accountTable).SetMap(dataMap).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return app.NewErrorFrom(app.ErrInternal).Wrap(err)
        }</span>

        <span class="cov0" title="0">_, err = r.txc.DefaultTrOrDB(ctx, r.db).Exec(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return convErr</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package repository

import (
        "context"
        "log/slog"
        "time"

        "github.com/Masterminds/squirrel"
        trmpgx "github.com/avito-tech/go-transaction-manager/drivers/pgxv5/v2"
        "github.com/georgysavva/scany/v2/pgxscan"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/m11ano/avito-shop/internal/app"
        "github.com/m11ano/avito-shop/internal/domain"
        "github.com/m11ano/avito-shop/internal/usecase"
        "github.com/m11ano/avito-shop/pkg/dbhelper"
)

const (
        coinTransferTable = "coin_transfer"
)

type DBCoinTransfer struct {
        ID                    uuid.UUID               `db:"transfer_id"`
        Type                  domain.CoinTransferType `db:"transfer_type"`
        OwnerAccountID        uuid.UUID               `db:"owner_account_id"`
        CounterpartyAccountID uuid.UUID               `db:"counterparty_account_id"`
        Amount                int64                   `db:"amount"`
        CreatedAt             time.Time               `db:"created_at"`
        IdentityKey           *uuid.UUID              `db:"identity_key"`
}

var (
        //nolint:unused
        coinTransferTableFields = []string{}
        coinTransferDBSchema    = &amp;DBCoinTransfer{}
)

func init() <span class="cov0" title="0">{
        coinTransferTableFields = dbhelper.ExtractDBFields(coinTransferDBSchema)
}</span>

type CoinTransfer struct {
        logger *slog.Logger
        db     *pgxpool.Pool
        txc    *trmpgx.CtxGetter
        qb     squirrel.StatementBuilderType
}

func NewCoinTransfer(logger *slog.Logger, db *pgxpool.Pool, txc *trmpgx.CtxGetter) *CoinTransfer <span class="cov0" title="0">{
        return &amp;CoinTransfer{
                logger: logger,
                db:     db,
                txc:    txc,
                qb:     squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar),
        }
}</span>

//nolint:unused
func (r *CoinTransfer) dbToDomain(db *DBCoinTransfer) *domain.CoinTransfer <span class="cov0" title="0">{
        return &amp;domain.CoinTransfer{
                ID:                    db.ID,
                Type:                  db.Type,
                OwnerAccountID:        db.OwnerAccountID,
                CounterpartyAccountID: db.CounterpartyAccountID,
                Amount:                db.Amount,
                CreatedAt:             db.CreatedAt,
                IdentityKey:           db.IdentityKey,
        }
}</span>

type CoinTransferCheckIdentityDTO struct {
        Count int `db:"count"`
}

func (r *CoinTransfer) FindIdentity(ctx context.Context, key uuid.UUID) (bool, error) <span class="cov0" title="0">{
        query, args, err := r.qb.Select("COUNT(*) as count").From(coinTransferTable).Where(squirrel.Eq{"identity_key": key}).Limit(1).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return false, app.NewErrorFrom(app.ErrInternal).Wrap(err)
        }</span>

        <span class="cov0" title="0">rows, err := r.txc.DefaultTrOrDB(ctx, r.db).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return false, convErr</span>
        }

        <span class="cov0" title="0">defer rows.Close()

        dbData := &amp;CoinTransferCheckIdentityDTO{}

        if err := pgxscan.ScanOne(dbData, rows); err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return false, convErr</span>
        }

        <span class="cov0" title="0">return dbData.Count &gt; 0, nil</span>
}

func (r *CoinTransfer) Create(ctx context.Context, item *domain.CoinTransfer) error <span class="cov0" title="0">{
        dataMap, err := dbhelper.StructToDBMap(item, coinTransferDBSchema)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "convert struct to db map", slog.Any("error", err))
                return app.NewErrorFrom(app.ErrInternal).Wrap(err)
        }</span>

        <span class="cov0" title="0">query, args, err := r.qb.Insert(coinTransferTable).SetMap(dataMap).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return app.NewErrorFrom(app.ErrInternal).Wrap(err)
        }</span>

        <span class="cov0" title="0">_, err = r.txc.DefaultTrOrDB(ctx, r.db).Exec(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return convErr</span>
        }

        <span class="cov0" title="0">return nil</span>
}

type CoinTransferAggrCoinHistoryItem struct {
        AccountID   uuid.UUID `db:"counterparty_account_id"`
        TotalAmount int64     `db:"total_amount"`
}

func (r *CoinTransfer) GetAggrCoinHistoryByAccountID(ctx context.Context, accountID uuid.UUID, transferType domain.CoinTransferType) ([]usecase.CoinTransferRepositoryAggrHistoryItem, error) <span class="cov0" title="0">{
        query, args, err := r.qb.Select("counterparty_account_id", "SUM(amount) as total_amount").From(coinTransferTable).Where(squirrel.Eq{"owner_account_id": accountID, "transfer_type": transferType}).GroupBy("counterparty_account_id").ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return nil, app.NewErrorFrom(app.ErrInternal).Wrap(err)
        }</span>

        <span class="cov0" title="0">rows, err := r.txc.DefaultTrOrDB(ctx, r.db).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov0" title="0">defer rows.Close()

        result := make([]usecase.CoinTransferRepositoryAggrHistoryItem, 0)

        for rows.Next() </span><span class="cov0" title="0">{
                data := CoinTransferAggrCoinHistoryItem{}
                if err := pgxscan.ScanRow(&amp;data, rows); err != nil </span><span class="cov0" title="0">{
                        errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                        if !errIsConv </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return nil, convErr</span>
                }
                <span class="cov0" title="0">result = append(result, usecase.CoinTransferRepositoryAggrHistoryItem{
                        AccountID: data.AccountID,
                        Ammount:   data.TotalAmount,
                })</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package repository

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "time"

        "github.com/Masterminds/squirrel"
        trmpgx "github.com/avito-tech/go-transaction-manager/drivers/pgxv5/v2"
        "github.com/avito-tech/go-transaction-manager/trm/v2/manager"
        "github.com/georgysavva/scany/v2/pgxscan"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/m11ano/avito-shop/internal/app"
        "github.com/m11ano/avito-shop/internal/domain"
        "github.com/m11ano/avito-shop/pkg/dbhelper"
)

const (
        operationTable        = "operation"
        operationBalanceTable = "operation_balance"
)

type DBOperation struct {
        ID         uuid.UUID                  `db:"operation_id"`
        Type       domain.OperationType       `db:"operation_type"`
        AccountID  uuid.UUID                  `db:"account_id"`
        Amount     int64                      `db:"amount"`
        SourceType domain.OperationSourceType `db:"source_type"`
        SourceID   *uuid.UUID                 `db:"source_id"`
        CreatedAt  time.Time                  `db:"created_at"`
}

var (
        //nolint:unused
        operationTableFields = []string{}
        operationDBSchema    = &amp;DBOperation{}
)

func init() <span class="cov0" title="0">{
        operationTableFields = dbhelper.ExtractDBFields(operationDBSchema)
}</span>

type Operation struct {
        logger    *slog.Logger
        db        *pgxpool.Pool
        txc       *trmpgx.CtxGetter
        qb        squirrel.StatementBuilderType
        txManager *manager.Manager
}

func NewOperation(logger *slog.Logger, db *pgxpool.Pool, txc *trmpgx.CtxGetter, txManager *manager.Manager) *Operation <span class="cov0" title="0">{
        return &amp;Operation{
                logger:    logger,
                db:        db,
                txc:       txc,
                qb:        squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar),
                txManager: txManager,
        }
}</span>

//nolint:unused
func (r *Operation) dbToDomain(db *DBOperation) *domain.Operation <span class="cov0" title="0">{
        item := &amp;domain.Operation{
                ID:         db.ID,
                Type:       db.Type,
                AccountID:  db.AccountID,
                Amount:     db.Amount,
                SourceType: db.SourceType,
                SourceID:   db.SourceID,
                CreatedAt:  db.CreatedAt,
        }
        if item.Type == domain.OperationTypeDecrease </span><span class="cov0" title="0">{
                item.Amount = -item.Amount
        }</span>
        <span class="cov0" title="0">return item</span>
}

func (r *Operation) domainToDB(item *domain.Operation) (map[string]interface{}, error) <span class="cov0" title="0">{
        dataMap, err := dbhelper.StructToDBMap(item, operationDBSchema)
        if err != nil </span><span class="cov0" title="0">{
                return nil, app.NewErrorFrom(app.ErrInternal).Wrap(err)
        }</span>

        <span class="cov0" title="0">if item.Type == domain.OperationTypeDecrease </span><span class="cov0" title="0">{
                dataMap["amount"] = -item.Amount
        }</span>

        <span class="cov0" title="0">return dataMap, nil</span>
}

type OperationGetBalanceDTO struct {
        Balance int64 `db:"balance"`
}

func (r *Operation) GetBalanceByAccountID(ctx context.Context, accountID uuid.UUID) (int64, bool, error) <span class="cov0" title="0">{
        query, args, err := r.qb.Select("balance").From(operationBalanceTable).Where(squirrel.Eq{"account_id": accountID}).Limit(1).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return 0, false, app.NewErrorFrom(app.ErrInternal).Wrap(err)
        }</span>

        <span class="cov0" title="0">rows, err := r.txc.DefaultTrOrDB(ctx, r.db).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return 0, false, convErr</span>
        }

        <span class="cov0" title="0">defer rows.Close()

        dbData := &amp;OperationGetBalanceDTO{}

        if err := pgxscan.ScanOne(dbData, rows); err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">if errors.Is(convErr, app.ErrStoreNoRows) </span><span class="cov0" title="0">{
                        return 0, false, nil
                }</span>
                <span class="cov0" title="0">return 0, false, convErr</span>
        }

        <span class="cov0" title="0">return dbData.Balance, true, nil</span>
}

// Внутренний метод, обновить баланс по логу операций
func (r *Operation) updateBalanceByAccountID(ctx context.Context, accountID uuid.UUID) error <span class="cov0" title="0">{
        updateQuery := squirrel.Expr("INSERT INTO operation_balance (account_id, balance) VALUES ($1, (SELECT COALESCE(SUM(amount), 0) FROM operation WHERE account_id = $1)) ON CONFLICT (account_id) DO UPDATE SET balance = (SELECT COALESCE(SUM(amount), 0) FROM operation WHERE account_id = $1)", accountID)

        query, args, err := updateQuery.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return app.NewErrorFrom(app.ErrInternal).Wrap(err)
        }</span>

        <span class="cov0" title="0">rows, err := r.txc.DefaultTrOrDB(ctx, r.db).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("CATCH")
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return convErr</span>
        }

        <span class="cov0" title="0">defer rows.Close()

        return nil</span>
}

func (r *Operation) Create(ctx context.Context, item *domain.Operation) (int64, error) <span class="cov0" title="0">{
        dataMap, err := r.domainToDB(item)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "convert struct to db map", slog.Any("error", err))
                return 0, err
        }</span>

        <span class="cov0" title="0">var balance int64

        // DOTO: подумать целесообразности ретраев при возникновении блокировки
        err = r.txManager.Do(ctx, func(ctx context.Context) error </span><span class="cov0" title="0">{
                query, args, err := r.qb.Insert(operationTable).SetMap(dataMap).ToSql()
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                        return app.NewErrorFrom(app.ErrInternal).Wrap(err)
                }</span>

                <span class="cov0" title="0">_, err = r.txc.DefaultTrOrDB(ctx, r.db).Exec(ctx, query, args...)
                if err != nil </span><span class="cov0" title="0">{
                        errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                        if !errIsConv </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return convErr</span>
                }

                // Если две конкурирующие транзакции попытаются обновить баланс аккаунта - одна из них получит блокировку
                <span class="cov0" title="0">err = r.updateBalanceByAccountID(ctx, item.AccountID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Далее если транзакция получила блокировку, здесь при попытке чтения вызовется ошибка
                <span class="cov0" title="0">balance, _, err = r.GetBalanceByAccountID(ctx, item.AccountID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return balance, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package repository

import (
        "context"
        "log/slog"

        "github.com/Masterminds/squirrel"
        trmpgx "github.com/avito-tech/go-transaction-manager/drivers/pgxv5/v2"
        "github.com/georgysavva/scany/v2/pgxscan"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/m11ano/avito-shop/internal/app"
        "github.com/m11ano/avito-shop/internal/domain"
        "github.com/m11ano/avito-shop/pkg/dbhelper"
)

const (
        shopItemTable = "shop_item"
)

type DBShopItem struct {
        ID    uuid.UUID `db:"item_id"`
        Name  string    `db:"item_name"`
        Price int64     `db:"price"`
}

var (
        shopItemTableFields = []string{}
        shopItemDBSchema    = &amp;DBShopItem{}
)

func init() <span class="cov0" title="0">{
        shopItemTableFields = dbhelper.ExtractDBFields(shopItemDBSchema)
}</span>

type ShopItem struct {
        logger *slog.Logger
        db     *pgxpool.Pool
        txc    *trmpgx.CtxGetter
        qb     squirrel.StatementBuilderType
}

func NewShopItem(logger *slog.Logger, db *pgxpool.Pool, txc *trmpgx.CtxGetter) *ShopItem <span class="cov0" title="0">{
        return &amp;ShopItem{
                logger: logger,
                db:     db,
                txc:    txc,
                qb:     squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar),
        }
}</span>

func (r *ShopItem) dbToDomain(db *DBShopItem) *domain.ShopItem <span class="cov0" title="0">{
        return &amp;domain.ShopItem{
                ID:    db.ID,
                Name:  db.Name,
                Price: db.Price,
        }
}</span>

func (r *ShopItem) FindItemByID(ctx context.Context, id uuid.UUID) (*domain.ShopItem, error) <span class="cov0" title="0">{
        query, args, err := r.qb.Select(shopItemTableFields...).From(shopItemTable).Where(squirrel.Eq{"item_id": id}).Limit(1).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return nil, app.NewErrorFrom(app.ErrInternal).Wrap(err)
        }</span>

        <span class="cov0" title="0">rows, err := r.txc.DefaultTrOrDB(ctx, r.db).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov0" title="0">defer rows.Close()

        dbData := &amp;DBShopItem{}

        if err := pgxscan.ScanOne(dbData, rows); err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov0" title="0">item := r.dbToDomain(dbData)

        return item, nil</span>
}

func (r *ShopItem) FindItemByName(ctx context.Context, name string) (*domain.ShopItem, error) <span class="cov0" title="0">{
        query, args, err := r.qb.Select(shopItemTableFields...).From(shopItemTable).Where(squirrel.Eq{"item_name": name}).Limit(1).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return nil, app.NewErrorFrom(app.ErrInternal).Wrap(err)
        }</span>

        <span class="cov0" title="0">rows, err := r.txc.DefaultTrOrDB(ctx, r.db).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov0" title="0">defer rows.Close()

        dbData := &amp;DBShopItem{}

        if err := pgxscan.ScanOne(dbData, rows); err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov0" title="0">item := r.dbToDomain(dbData)

        return item, nil</span>
}

func (r *ShopItem) FindItemsByIDs(ctx context.Context, ids []uuid.UUID) (map[uuid.UUID]domain.ShopItem, error) <span class="cov0" title="0">{
        query, args, err := r.qb.Select(shopItemTableFields...).From(shopItemTable).Where(squirrel.Eq{"item_id": ids}).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return nil, app.NewErrorFrom(app.ErrInternal).Wrap(err)
        }</span>

        <span class="cov0" title="0">rows, err := r.txc.DefaultTrOrDB(ctx, r.db).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov0" title="0">defer rows.Close()

        result := map[uuid.UUID]domain.ShopItem{}

        for rows.Next() </span><span class="cov0" title="0">{
                data := &amp;DBShopItem{}
                if err := pgxscan.ScanRow(data, rows); err != nil </span><span class="cov0" title="0">{
                        errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                        if !errIsConv </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return nil, convErr</span>
                }
                <span class="cov0" title="0">domainItem := *r.dbToDomain(data)
                result[domainItem.ID] = domainItem</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package repository

import (
        "context"
        "log/slog"
        "time"

        "github.com/Masterminds/squirrel"
        trmpgx "github.com/avito-tech/go-transaction-manager/drivers/pgxv5/v2"
        "github.com/georgysavva/scany/v2/pgxscan"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/m11ano/avito-shop/internal/app"
        "github.com/m11ano/avito-shop/internal/domain"
        "github.com/m11ano/avito-shop/internal/usecase"
        "github.com/m11ano/avito-shop/pkg/dbhelper"
)

const (
        shopPurchaseTable = "shop_purchase"
)

type DBShopPurchase struct {
        ID          uuid.UUID  `db:"purchase_id"`
        ItemID      uuid.UUID  `db:"item_id"`
        AccountID   uuid.UUID  `db:"account_id"`
        Quantity    int64      `db:"quantity"`
        CreatedAt   time.Time  `db:"created_at"`
        IdentityKey *uuid.UUID `db:"identity_key"`
}

var (
        //nolint:unused
        shopPurchaseTableFields = []string{}
        shopPurchaseDBSchema    = &amp;DBShopPurchase{}
)

func init() <span class="cov0" title="0">{
        shopPurchaseTableFields = dbhelper.ExtractDBFields(shopPurchaseDBSchema)
}</span>

type ShopPurchase struct {
        logger *slog.Logger
        db     *pgxpool.Pool
        txc    *trmpgx.CtxGetter
        qb     squirrel.StatementBuilderType
}

func NewShopPurchase(logger *slog.Logger, db *pgxpool.Pool, txc *trmpgx.CtxGetter) *ShopPurchase <span class="cov0" title="0">{
        return &amp;ShopPurchase{
                logger: logger,
                db:     db,
                txc:    txc,
                qb:     squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar),
        }
}</span>

//nolint:unused
func (r *ShopPurchase) dbToDomain(db *DBShopPurchase) *domain.ShopPurchase <span class="cov0" title="0">{
        return &amp;domain.ShopPurchase{
                ID:          db.ID,
                ItemID:      db.ItemID,
                AccountID:   db.AccountID,
                Quantity:    db.Quantity,
                CreatedAt:   db.CreatedAt,
                IdentityKey: db.IdentityKey,
        }
}</span>

type ShopPurchaseCheckIdentityDTO struct {
        Count int `db:"count"`
}

func (r *ShopPurchase) FindIdentity(ctx context.Context, key uuid.UUID) (bool, error) <span class="cov0" title="0">{
        query, args, err := r.qb.Select("COUNT(*) as count").From(shopPurchaseTable).Where(squirrel.Eq{"identity_key": key}).Limit(1).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return false, app.NewErrorFrom(app.ErrInternal).Wrap(err)
        }</span>

        <span class="cov0" title="0">rows, err := r.txc.DefaultTrOrDB(ctx, r.db).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return false, convErr</span>
        }

        <span class="cov0" title="0">defer rows.Close()

        dbData := &amp;ShopPurchaseCheckIdentityDTO{}

        if err := pgxscan.ScanOne(dbData, rows); err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return false, convErr</span>
        }

        <span class="cov0" title="0">return dbData.Count &gt; 0, nil</span>
}

func (r *ShopPurchase) Create(ctx context.Context, item *domain.ShopPurchase) error <span class="cov0" title="0">{
        dataMap, err := dbhelper.StructToDBMap(item, shopPurchaseDBSchema)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "convert struct to db map", slog.Any("error", err))
                return app.NewErrorFrom(app.ErrInternal).Wrap(err)
        }</span>

        <span class="cov0" title="0">query, args, err := r.qb.Insert(shopPurchaseTable).SetMap(dataMap).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return app.NewErrorFrom(app.ErrInternal).Wrap(err)
        }</span>

        <span class="cov0" title="0">_, err = r.txc.DefaultTrOrDB(ctx, r.db).Exec(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return convErr</span>
        }

        <span class="cov0" title="0">return nil</span>
}

type ShopPurchaseAggrInventoryItem struct {
        ItemID        uuid.UUID `db:"item_id"`
        TotalQuantity int64     `db:"total_quantity"`
}

func (r *ShopPurchase) AggrInventoryByAccountID(ctx context.Context, accountID uuid.UUID) ([]usecase.ShopPurchaseRepositoryAggrInventoryItem, error) <span class="cov0" title="0">{
        query, args, err := r.qb.Select("item_id", "SUM(quantity) as total_quantity").From(shopPurchaseTable).Where(squirrel.Eq{"account_id": accountID}).GroupBy("item_id").ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(ctx, "building query", slog.Any("error", err))
                return nil, app.NewErrorFrom(app.ErrInternal).Wrap(err)
        }</span>

        <span class="cov0" title="0">rows, err := r.txc.DefaultTrOrDB(ctx, r.db).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov0" title="0">defer rows.Close()

        result := make([]usecase.ShopPurchaseRepositoryAggrInventoryItem, 0)

        for rows.Next() </span><span class="cov0" title="0">{
                data := ShopPurchaseAggrInventoryItem{}
                if err := pgxscan.ScanRow(&amp;data, rows); err != nil </span><span class="cov0" title="0">{
                        errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                        if !errIsConv </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return nil, convErr</span>
                }
                <span class="cov0" title="0">result = append(result, usecase.ShopPurchaseRepositoryAggrInventoryItem{
                        ShopItemID: data.ItemID,
                        Quantity:   data.TotalQuantity,
                })</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                errIsConv, convErr := app.ErrConvertPgxToLogic(err)
                if !errIsConv </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(ctx, "scan row", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, convErr</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package usecase

import (
        "context"
        "log/slog"

        "github.com/avito-tech/go-transaction-manager/trm/v2/manager"
        "github.com/google/uuid"
        "github.com/m11ano/avito-shop/internal/config"
        "github.com/m11ano/avito-shop/internal/domain"
)

//go:generate mockery --name=Account --output=../../tests/mocks --case=underscore
type Account interface {
        GetItemByUsername(ctx context.Context, username string) (account *domain.Account, err error)
        GetItemsByIDs(ctx context.Context, ids []uuid.UUID) (accounts map[uuid.UUID]domain.Account, err error)
        Create(ctx context.Context, account *domain.Account) error
}

//go:generate mockery --name=AccountRepository --output=../../tests/mocks --case=underscore
type AccountRepository interface {
        FindItemByUsername(ctx context.Context, username string) (account *domain.Account, err error)
        FindItemsByIDs(ctx context.Context, ids []uuid.UUID) (accounts map[uuid.UUID]domain.Account, err error)
        Create(ctx context.Context, account *domain.Account) error
}

type AccountInpl struct {
        logger    *slog.Logger
        config    config.Config
        repo      AccountRepository
        txManager *manager.Manager
}

func NewAccountInpl(logger *slog.Logger, config config.Config, txManager *manager.Manager, repo AccountRepository) *AccountInpl <span class="cov8" title="1">{
        uc := &amp;AccountInpl{
                logger:    logger,
                config:    config,
                txManager: txManager,
                repo:      repo,
        }
        return uc
}</span>

func (uc *AccountInpl) GetItemByUsername(ctx context.Context, username string) (*domain.Account, error) <span class="cov8" title="1">{
        return uc.repo.FindItemByUsername(ctx, username)
}</span>

func (uc *AccountInpl) GetItemsByIDs(ctx context.Context, ids []uuid.UUID) (map[uuid.UUID]domain.Account, error) <span class="cov8" title="1">{
        return uc.repo.FindItemsByIDs(ctx, ids)
}</span>

func (uc *AccountInpl) Create(ctx context.Context, item *domain.Account) error <span class="cov8" title="1">{
        return uc.repo.Create(ctx, item)
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package usecase

import (
        "context"
        "errors"
        "log/slog"
        "strconv"
        "time"

        "github.com/avito-tech/go-transaction-manager/trm/v2/manager"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "github.com/m11ano/avito-shop/internal/app"
        "github.com/m11ano/avito-shop/internal/config"
        "github.com/m11ano/avito-shop/internal/domain"
)

//go:generate mockery --name=Auth --output=../../tests/mocks --case=underscore
type Auth interface {
        SignInOrSignUp(ctx context.Context, username string, password string) (jwtToken string, err error)
        AuthByJWTToken(ctx context.Context, jwtToken string) (accountID *uuid.UUID, err error)
}

type AuthInpl struct {
        logger           *slog.Logger
        config           config.Config
        txManager        *manager.Manager
        usecaseAccount   Account
        usecaseOperation Operation
}

func NewAuthInpl(logger *slog.Logger, config config.Config, txManager *manager.Manager, usecaseAccount Account, usecaseOperation Operation) *AuthInpl <span class="cov8" title="1">{
        uc := &amp;AuthInpl{
                logger:           logger,
                config:           config,
                txManager:        txManager,
                usecaseAccount:   usecaseAccount,
                usecaseOperation: usecaseOperation,
        }
        return uc
}</span>

func (uc *AuthInpl) generateJWTToken(ctx context.Context, account *domain.Account) (string, error) <span class="cov8" title="1">{
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "accountID": account.ID.String(),
                "createdAt": strconv.FormatInt(time.Now().Unix(), 10),
        })

        tokenStr, err := token.SignedString([]byte(uc.config.Auth.JWTSecretKey))
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.ErrorContext(ctx, "jwt sign error", slog.Any("error", err))
                return "", app.NewErrorFrom(app.ErrInternal).Wrap(err)
        }</span>

        <span class="cov8" title="1">return tokenStr, nil</span>
}

func (uc *AuthInpl) SignInOrSignUp(ctx context.Context, username string, password string) (string, error) <span class="cov8" title="1">{
        var account *domain.Account
        var err error

        err = uc.txManager.Do(ctx, func(ctx context.Context) error </span><span class="cov8" title="1">{
                account, err = uc.usecaseAccount.GetItemByUsername(ctx, username)
                if err != nil &amp;&amp; errors.Is(err, app.ErrNotFound) </span><span class="cov8" title="1">{
                        account, err = domain.NewAccount(username, password)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">err = uc.usecaseAccount.Create(ctx, account)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if uc.config.Auth.NewAccountAmount &gt; 0 </span><span class="cov8" title="1">{
                                depositOp := domain.NewOperation(domain.OperationTypeIncrease, account.ID, uc.config.Auth.NewAccountAmount, domain.OperationSourceTypeDeposit, nil)
                                _, err := uc.usecaseOperation.SaveOperation(ctx, depositOp)
                                if err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                        }
                } else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if !app.IsAppError(err) </span><span class="cov8" title="1">{
                        return "", app.NewErrorFrom(app.ErrInternal).Wrap(err)
                }</span>
                <span class="cov8" title="1">return "", err</span>
        }

        <span class="cov8" title="1">check := account.VerifyPassword(password)
        if !check </span><span class="cov8" title="1">{
                return "", app.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">return uc.generateJWTToken(ctx, account)</span>
}

func (uc *AuthInpl) AuthByJWTToken(ctx context.Context, tokenStr string) (*uuid.UUID, error) <span class="cov8" title="1">{
        claims := jwt.MapClaims{}
        token, err := jwt.ParseWithClaims(tokenStr, claims, func(_ *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                return []byte(uc.config.Auth.JWTSecretKey), nil
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                uc.logger.ErrorContext(ctx, "parse jwt", slog.Any("error", err))
                return nil, app.NewErrorFrom(app.ErrUnauthorized).Wrap(err)
        }</span>

        <span class="cov8" title="1">if !token.Valid </span><span class="cov0" title="0">{
                return nil, app.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">var accountIDStr string
        var createdAtStr string
        var createdAt int64
        var ok bool

        if accountIDStr, ok = claims["accountID"].(string); !ok </span><span class="cov8" title="1">{
                return nil, app.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">if createdAtStr, ok = claims["createdAt"].(string); !ok </span><span class="cov8" title="1">{
                return nil, app.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">createdAt, err = strconv.ParseInt(createdAtStr, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return nil, app.NewErrorFrom(app.ErrUnauthorized).Wrap(err)
        }</span>

        <span class="cov8" title="1">accountID, err := uuid.Parse(accountIDStr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, app.NewErrorFrom(app.ErrUnauthorized).Wrap(err)
        }</span>

        <span class="cov8" title="1">if time.Now().Unix()-createdAt &gt; uc.config.Auth.JWTTokenTTL </span><span class="cov8" title="1">{
                return nil, app.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">return &amp;accountID, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package usecase

import (
        "context"
        "log/slog"

        "github.com/avito-tech/go-transaction-manager/trm/v2/manager"
        "github.com/google/uuid"
        "github.com/m11ano/avito-shop/internal/app"
        "github.com/m11ano/avito-shop/internal/config"
        "github.com/m11ano/avito-shop/internal/domain"
)

type CoinTransferGetAggrHistoryItem struct {
        Account *domain.Account
        Amount  int64
}

//go:generate mockery --name=CoinTransfer --output=../../tests/mocks --case=underscore
type CoinTransfer interface {
        MakeTransferByUsername(ctx context.Context, targetAccountUsername string, ownerAccountID uuid.UUID, amount int64, identityKey *uuid.UUID) (ownerCoinTransfer *domain.CoinTransfer, targetCoinTransfer *domain.CoinTransfer, err error)
        GetAggrCoinHistory(ctx context.Context, accountID uuid.UUID, transferType domain.CoinTransferType) (aggrHistory []CoinTransferGetAggrHistoryItem, err error)
}

type CoinTransferRepositoryAggrHistoryItem struct {
        AccountID uuid.UUID
        Ammount   int64
}

//go:generate mockery --name=CoinTransferRepository --output=../../tests/mocks --case=underscore
type CoinTransferRepository interface {
        FindIdentity(ctx context.Context, identityKey uuid.UUID) (found bool, err error)
        Create(ctx context.Context, coinTransfer *domain.CoinTransfer) error
        GetAggrCoinHistoryByAccountID(ctx context.Context, accountID uuid.UUID, transferType domain.CoinTransferType) (aggrHistory []CoinTransferRepositoryAggrHistoryItem, err error)
}

type CoinTransferInpl struct {
        logger           *slog.Logger
        config           config.Config
        repo             CoinTransferRepository
        txManager        *manager.Manager
        usecaseAccount   Account
        usecaseOperation Operation
}

func NewCoinTransferInpl(logger *slog.Logger, config config.Config, txManager *manager.Manager, repo CoinTransferRepository, usecaseAccount Account, usecaseOperation Operation) *CoinTransferInpl <span class="cov0" title="0">{
        uc := &amp;CoinTransferInpl{
                logger:           logger,
                config:           config,
                txManager:        txManager,
                repo:             repo,
                usecaseAccount:   usecaseAccount,
                usecaseOperation: usecaseOperation,
        }
        return uc
}</span>

// Make coin transfer from owner to target
func (uc *CoinTransferInpl) MakeTransferByUsername(ctx context.Context, targetAccountUsername string, ownerAccountID uuid.UUID, ammount int64, identityKey *uuid.UUID) (*domain.CoinTransfer, *domain.CoinTransfer, error) <span class="cov0" title="0">{
        var err error
        var transferForOwner *domain.CoinTransfer
        var transferForTarget *domain.CoinTransfer

        err = uc.txManager.Do(ctx, func(ctx context.Context) error </span><span class="cov0" title="0">{
                if identityKey != nil </span><span class="cov0" title="0">{
                        isIdentityExists, err := uc.repo.FindIdentity(ctx, *identityKey)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if isIdentityExists </span><span class="cov0" title="0">{
                                return app.ErrConflict
                        }</span>
                }

                <span class="cov0" title="0">targetAccount, err := uc.usecaseAccount.GetItemByUsername(ctx, targetAccountUsername)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if targetAccount.ID == ownerAccountID </span><span class="cov0" title="0">{
                        return app.NewErrorFrom(app.ErrConflict).SetMessage("cant send coin to yourself")
                }</span>

                <span class="cov0" title="0">transferForTarget = domain.NewCoinTransfer(domain.CoinTransferTypeReciving, ownerAccountID, targetAccount.ID, ammount, identityKey)
                transferForOwner = domain.NewCoinTransfer(domain.CoinTransferTypeSending, targetAccount.ID, ownerAccountID, ammount, identityKey)

                operationForTarget := domain.NewOperation(domain.OperationTypeIncrease, targetAccount.ID, ammount, domain.OperationSourceTypeTransfer, &amp;transferForTarget.ID)
                operationForOwner := domain.NewOperation(domain.OperationTypeDecrease, ownerAccountID, ammount, domain.OperationSourceTypeTransfer, &amp;transferForOwner.ID)

                _, err = uc.usecaseOperation.SaveOperation(ctx, operationForOwner)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">_, err = uc.usecaseOperation.SaveOperation(ctx, operationForTarget)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">err = uc.repo.Create(ctx, transferForOwner)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">err = uc.repo.Create(ctx, transferForTarget)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if !app.IsAppError(err) </span><span class="cov0" title="0">{
                        return nil, nil, app.NewErrorFrom(app.ErrInternal).Wrap(err)
                }</span>
                <span class="cov0" title="0">return nil, nil, err</span>
        }

        <span class="cov0" title="0">return transferForOwner, transferForTarget, nil</span>
}

func (uc *CoinTransferInpl) GetAggrCoinHistory(ctx context.Context, accountID uuid.UUID, transferType domain.CoinTransferType) ([]CoinTransferGetAggrHistoryItem, error) <span class="cov0" title="0">{
        history, err := uc.repo.GetAggrCoinHistoryByAccountID(ctx, accountID, transferType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">accountIDs := make([]uuid.UUID, 0, len(history))
        for _, item := range history </span><span class="cov0" title="0">{
                accountIDs = append(accountIDs, item.AccountID)
        }</span>

        <span class="cov0" title="0">accountItems, err := uc.usecaseAccount.GetItemsByIDs(ctx, accountIDs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result := make([]CoinTransferGetAggrHistoryItem, 0, len(history))

        for _, item := range history </span><span class="cov0" title="0">{
                resultItem := CoinTransferGetAggrHistoryItem{
                        Amount: item.Ammount,
                }
                if accountItem, ok := accountItems[item.AccountID]; ok </span><span class="cov0" title="0">{
                        resultItem.Account = &amp;accountItem
                }</span>

                <span class="cov0" title="0">result = append(result, resultItem)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package usecase

import (
        "context"
        "log/slog"

        "github.com/avito-tech/go-transaction-manager/trm/v2/manager"
        "github.com/google/uuid"
        "github.com/m11ano/avito-shop/internal/app"
        "github.com/m11ano/avito-shop/internal/config"
        "github.com/m11ano/avito-shop/internal/domain"
)

var ErrOperationNotEnoughFunds = app.NewErrorFrom(app.ErrUnprocessableEntity).SetMessage("not enough funds")

//go:generate mockery --name=Operation --output=../../tests/mocks --case=underscore
type Operation interface {
        GetBalanceByAccountID(ctx context.Context, accountID uuid.UUID) (balance int64, found bool, err error)
        SaveOperation(ctx context.Context, operation *domain.Operation) (balance int64, err error)
}

//go:generate mockery --name=OperationRepository --output=../../tests/mocks --case=underscore
type OperationRepository interface {
        GetBalanceByAccountID(ctx context.Context, accountID uuid.UUID) (balance int64, found bool, err error)
        Create(ctx context.Context, operation *domain.Operation) (balance int64, err error)
}

type OperationInpl struct {
        logger    *slog.Logger
        config    config.Config
        repo      OperationRepository
        txManager *manager.Manager
}

func NewOperationInpl(logger *slog.Logger, config config.Config, txManager *manager.Manager, repo OperationRepository) *OperationInpl <span class="cov8" title="1">{
        uc := &amp;OperationInpl{
                logger:    logger,
                config:    config,
                txManager: txManager,
                repo:      repo,
        }
        return uc
}</span>

func (uc *OperationInpl) SaveOperation(ctx context.Context, operation *domain.Operation) (int64, error) <span class="cov8" title="1">{
        var err error
        var balance int64
        switch operation.Type </span>{
        case domain.OperationTypeDecrease:<span class="cov8" title="1">
                // Если списание - проверим баланс в транзакции и если меньше 0 - откатим принудительно и вернем ошибку
                err = uc.txManager.Do(ctx, func(ctx context.Context) error </span><span class="cov8" title="1">{
                        balance, err = uc.repo.Create(ctx, operation)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if balance &lt; 0 </span><span class="cov8" title="1">{
                                return ErrOperationNotEnoughFunds
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                })
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        return 0, err
                }</span>
        case domain.OperationTypeIncrease:<span class="cov8" title="1">
                // Если пополнение - просто сохраняем
                balance, err = uc.repo.Create(ctx, operation)
                if err != nil </span><span class="cov8" title="1">{
                        return 0, err
                }</span>
        }

        <span class="cov8" title="1">return balance, nil</span>
}

func (uc *OperationInpl) GetBalanceByAccountID(ctx context.Context, accountID uuid.UUID) (int64, bool, error) <span class="cov8" title="1">{
        return uc.repo.GetBalanceByAccountID(ctx, accountID)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package usecase

import (
        "context"

        "github.com/google/uuid"
        "github.com/m11ano/avito-shop/internal/domain"
)

//go:generate mockery --name=ShopItem --output=../../tests/mocks --case=underscore
type ShopItem interface {
        GetItemByID(ctx context.Context, id uuid.UUID) (shopItem *domain.ShopItem, err error)
        GetItemByName(ctx context.Context, name string) (shopItem *domain.ShopItem, err error)
        GetItemsByIDs(ctx context.Context, ids []uuid.UUID) (shopItems map[uuid.UUID]domain.ShopItem, err error)
}

//go:generate mockery --name=ShopItemRepository --output=../../tests/mocks --case=underscore
type ShopItemRepository interface {
        FindItemByID(ctx context.Context, id uuid.UUID) (shopItem *domain.ShopItem, err error)
        FindItemByName(ctx context.Context, name string) (shopItem *domain.ShopItem, err error)
        FindItemsByIDs(ctx context.Context, ids []uuid.UUID) (shopItems map[uuid.UUID]domain.ShopItem, err error)
}

type ShopItemInpl struct {
        repo ShopItemRepository
}

func NewShopItemInpl(repo ShopItemRepository) *ShopItemInpl <span class="cov0" title="0">{
        uc := &amp;ShopItemInpl{
                repo: repo,
        }
        return uc
}</span>

func (uc *ShopItemInpl) GetItemByID(ctx context.Context, id uuid.UUID) (*domain.ShopItem, error) <span class="cov0" title="0">{
        return uc.repo.FindItemByID(ctx, id)
}</span>

func (uc *ShopItemInpl) GetItemByName(ctx context.Context, name string) (*domain.ShopItem, error) <span class="cov0" title="0">{
        return uc.repo.FindItemByName(ctx, name)
}</span>

func (uc *ShopItemInpl) GetItemsByIDs(ctx context.Context, ids []uuid.UUID) (map[uuid.UUID]domain.ShopItem, error) <span class="cov0" title="0">{
        return uc.repo.FindItemsByIDs(ctx, ids)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package usecase

import (
        "context"
        "log/slog"

        "github.com/avito-tech/go-transaction-manager/trm/v2/manager"
        "github.com/google/uuid"
        "github.com/m11ano/avito-shop/internal/app"
        "github.com/m11ano/avito-shop/internal/config"
        "github.com/m11ano/avito-shop/internal/domain"
)

type ShopPurchaseGetInventoryItem struct {
        ShopItem *domain.ShopItem
        Quantity int64
}

//go:generate mockery --name=ShopPurchase --output=../../tests/mocks --case=underscore
type ShopPurchase interface {
        MakePurchase(ctx context.Context, shopItemName string, ownerAccountID uuid.UUID, quantity int64, identityKey *uuid.UUID) (shopPurchase *domain.ShopPurchase, err error)
        GetInventory(ctx context.Context, accountID uuid.UUID) (inventory []ShopPurchaseGetInventoryItem, err error)
}

type ShopPurchaseRepositoryAggrInventoryItem struct {
        ShopItemID uuid.UUID
        Quantity   int64
}

//go:generate mockery --name=ShopPurchaseRepository --output=../../tests/mocks --case=underscore
type ShopPurchaseRepository interface {
        FindIdentity(ctx context.Context, identityKey uuid.UUID) (found bool, err error)
        Create(ctx context.Context, shopPurchase *domain.ShopPurchase) error
        AggrInventoryByAccountID(ctx context.Context, accountID uuid.UUID) (inventory []ShopPurchaseRepositoryAggrInventoryItem, err error)
}

type ShopPurchaseInpl struct {
        logger           *slog.Logger
        config           config.Config
        repo             ShopPurchaseRepository
        txManager        *manager.Manager
        usecaseAccount   Account
        usecaseOperation Operation
        usecaseShopItem  ShopItem
}

func NewShopPurchaseInpl(logger *slog.Logger, config config.Config, txManager *manager.Manager, repo ShopPurchaseRepository, usecaseAccount Account, usecaseOperation Operation, usecaseShopItem ShopItem) *ShopPurchaseInpl <span class="cov0" title="0">{
        uc := &amp;ShopPurchaseInpl{
                logger:           logger,
                config:           config,
                txManager:        txManager,
                repo:             repo,
                usecaseAccount:   usecaseAccount,
                usecaseOperation: usecaseOperation,
                usecaseShopItem:  usecaseShopItem,
        }
        return uc
}</span>

func (uc *ShopPurchaseInpl) MakePurchase(ctx context.Context, itemName string, accountID uuid.UUID, quantity int64, identityKey *uuid.UUID) (*domain.ShopPurchase, error) <span class="cov0" title="0">{
        var err error
        var shopPurchase *domain.ShopPurchase

        err = uc.txManager.Do(ctx, func(ctx context.Context) error </span><span class="cov0" title="0">{
                if identityKey != nil </span><span class="cov0" title="0">{
                        isIdentityExists, err := uc.repo.FindIdentity(ctx, *identityKey)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if isIdentityExists </span><span class="cov0" title="0">{
                                return app.ErrConflict
                        }</span>
                }

                <span class="cov0" title="0">shopItem, err := uc.usecaseShopItem.GetItemByName(ctx, itemName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">shopPurchase = domain.NewShopPurchase(shopItem.ID, accountID, quantity, identityKey)

                operation := domain.NewOperation(domain.OperationTypeDecrease, accountID, shopItem.Price*quantity, domain.OperationSourceTypeShopPurchase, &amp;shopPurchase.ID)

                _, err = uc.usecaseOperation.SaveOperation(ctx, operation)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">err = uc.repo.Create(ctx, shopPurchase)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if !app.IsAppError(err) </span><span class="cov0" title="0">{
                        return nil, app.NewErrorFrom(app.ErrInternal).Wrap(err)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return shopPurchase, nil</span>
}

func (uc *ShopPurchaseInpl) GetInventory(ctx context.Context, accountID uuid.UUID) ([]ShopPurchaseGetInventoryItem, error) <span class="cov0" title="0">{
        inventory, err := uc.repo.AggrInventoryByAccountID(ctx, accountID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">shopItemsIDs := make([]uuid.UUID, 0, len(inventory))
        for _, item := range inventory </span><span class="cov0" title="0">{
                shopItemsIDs = append(shopItemsIDs, item.ShopItemID)
        }</span>

        <span class="cov0" title="0">shopItems, err := uc.usecaseShopItem.GetItemsByIDs(ctx, shopItemsIDs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result := make([]ShopPurchaseGetInventoryItem, 0, len(inventory))

        for _, item := range inventory </span><span class="cov0" title="0">{
                resultItem := ShopPurchaseGetInventoryItem{
                        Quantity: item.Quantity,
                }
                if shopItem, ok := shopItems[item.ShopItemID]; ok </span><span class="cov0" title="0">{
                        resultItem.ShopItem = &amp;shopItem
                }</span>

                <span class="cov0" title="0">result = append(result, resultItem)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
